Metadata-Version: 2.1
Name: pathfinding3d
Version: 0.4.1
Summary: Pathfinding algorithms in 3D (based on python-pathfinding)
Home-page: https://github.com/harisankar95/pathfinding3D
Author: Harisankar Babu
License: MIT
Description: # Pathfinding3D
        
        [![MIT License](https://img.shields.io/github/license/harisankar95/pathfinding3d)](LICENSE)
        [![PyPI](https://img.shields.io/pypi/v/pathfinding3d)](https://pypi.org/project/pathfinding3d/)
        [![Pipeline](https://github.com/harisankar95/pathfinding3D/actions/workflows/test-main.yml/badge.svg?branch=main)](https://github.com/harisankar95/pathfinding3D/actions/workflows/test-main.yml)
        [![codecov](https://codecov.io/gh/harisankar95/pathfinding3D/branch/main/graph/badge.svg?token=ZQZQZQZQZQ)](https://codecov.io/gh/harisankar95/pathfinding3D)
        [![codestyle](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)
        
        Pathfinding algorithms for python3 froked from [python-pathfinding](https://github.com/brean/python-pathfinding) by [@brean](https://github.com/brean).
        
        Currently there are 7 path-finders bundled in this library, namely:
        
        - A*
        - Dijkstra
        - Best-First
        - Bi-directional A*
        - Breadth First Search (BFS)
        - Iterative Deeping A\* (IDA*)
        - Minimum Spanning Tree (MSP)
        
        Dijkstra, A\* and Bi-directional A\* take the weight of the fields on the map into account.
        
        ## Installation
        
        The package is available on pypi, so you can install it with pip:
        
        ```bash
        pip install pathfinding3d
        ```
        
        see [pathfinding3d on pypi](https://pypi.org/project/pathfinding3d/)
        
        ## Usage examples
        
        For usage examples with detailed descriptions take a look at the [examples](examples/) folder, also take a look at the [test/](test/) folder for more examples.
        
        ## Rerun the algorithm
        
        While running the pathfinding algorithm it might set values on the nodes. Depending on your path finding algorithm things like calculated distances or visited flags might be stored on them. So if you want to run the algorithm in a loop you need to clean the grid first (see `Grid.cleanup`). Please note that because cleanup looks at all nodes of the grid it might be an operation that can take a bit of time!
        
        ## Implementation details
        
        All pathfinding algorithms in this library are inheriting the Finder class. It has some common functionality that can be overwritten by the implementation of a path finding algorithm.
        
        The normal process works like this:
        
        1. You call `find_path` on one of your finder implementations.
        1. `init_find` instantiates the `open_list` and resets all values and counters.
        1. The main loop starts on the `open_list`. This list gets filled with all nodes that will be processed next (e.g. all current neighbors that are walkable). For this you need to implement `check_neighbors` in your own finder implementation.
        1. For example in A\*s implementation of `check_neighbors` you first want to get the next node closest from the current starting point from the open list. the `next_node` method in Finder does this by giving you the node with a minimum `f`-value from the open list, it closes it and removes it from the `open_list`.
        1. if this node is not the end node we go on and get its neighbors by calling `find_neighbors`. This just calls `grid.neighbors` for most algorithms.
        1. If none of the neighbors are the end node we want to process the neighbors to calculate their distances in `process_node`
        1. `process_node` calculates the cost `f` from the start to the current node using the `calc_cost` method and the cost after calculating `h` from `apply_heuristic`.
        1. finally `process_node` updates the open list so `find_path` can run `check_neighbors` on it in the next node in the next iteration of the main loop.
        
        flow:
        
        ```pseudo
          find_path
            init_find  # (re)set global values and open list
            check_neighbors  # for every node in open list
              next_node  # closest node to start in open list
              find_neighbors  # get neighbors
              process_node  # calculate new cost for neighboring node
        ```
        
        ## Testing
        
        You can run the tests locally using pytest. Take a look at the `test`-folder
        
        ## Contributing
        
        Please use the [issue tracker](https://github.com/harisankar95/pathfinding3D/issues) to submit bug reports and feature requests. Please use merge requests as described [here](/CONTRIBUTING.md) to add/adapt functionality.
        
        ## License
        
        python-pathfinding is distributed under the [MIT license](https://opensource.org/licenses/MIT).
        
        ## Authors / Contributers
        
        Authors and contributers are [listed on github](https://github.com/harisankar95/pathfinding3D/graphs/contributors).
        
Keywords: pathfinding,pathplanning,python,3D,A*,Dijkstra
Platform: UNKNOWN
Classifier: Development Status :: 3 - Alpha
Classifier: License :: OSI Approved :: MIT License
Classifier: Natural Language :: English
Classifier: Operating System :: OS Independent
Classifier: Programming Language :: Python :: 3.8
Description-Content-Type: text/markdown
Provides-Extra: dev
