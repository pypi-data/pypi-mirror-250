<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>abstochkin.process API documentation</title>
<meta name="description" content="Define a process of the form Reactants -&gt; Products." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>abstochkin.process</code></h1>
</header>
<section id="section-intro">
<p>Define a process of the form Reactants -&gt; Products.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34; Define a process of the form Reactants -&gt; Products. &#34;&#34;&#34;

#  Copyright (c) 2023, Alex Plakantonakis.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

import contextlib
import re
from typing import Self

from numpy import array


class Process:
    &#34;&#34;&#34;
    Define a unidirectional process: Reactants -&gt; Products, where the
    Reactants and Products are specified using standard chemical notation.
    That is, stoichiometric coefficients (integers) and species names are
    specified. For example: 2A + B -&gt; C.

    Attributes
    ----------
    reactants : dict
        The reactants of a given process are specified with
        key-value pairs describing each species name and its
        stoichiometric coefficient, respectively.
    products : dict
        The products of a given process are specified with
        key-value pairs describing each species name and its
        stoichiometric coefficient, respectively.
    k : float, int, list of floats, tuple of floats
        The *microscopic* rate constant(s) for the given process. The data
        type of `k` determines the &#34;structure&#34; of the population as follows:
            - A homogeneous population: if `k` is a single value (float or int),
              then the population is assumed to be homogeneous with all agents
              of the reactant species having kinetics defined by this value.
            - A heterogeneous population with a distinct number of subspecies
              (each with a corresponding `k` value): if `k` is a list of floats,
              then the population is assumed to be heterogeneous with a number
              of subspecies equal to the length of the list.
            - A heterogeneous population with normally-distributed `k` values:
              If `k` is a tuple whose length is 2, then the population is
              assumed to be heterogeneous with a normally distributed `k` value.
              The two entries in the tuple represent the mean and standard
              deviation (in that order) of the desired normal distribution.
    order : int
        The order of the process (or the molecularity of an elementary process).
        It is the sum of the stoichiometric coefficients of the reactants.
    species : set of strings
        A set of all species in a process.
    reacts_ : list of strings
        A list containing all the reactants in a process.
    prods_ : list of strings
        A list containing all the products in a process.

    Methods
    -------
    from_string
        Class method for creating a Process object from a string.
    &#34;&#34;&#34;

    def __init__(self,
                 reactants: dict,
                 products: dict,
                 k: float | int | list[float, ...] | tuple[float, float],
                 **kwargs):

        self.reactants = reactants
        self.products = products
        self.k = k

        self._validate_nums()  # make sure there are no errors in given numbers

        # For consistency with processes instantiated using the class method `from_string()`,
        # species denoted as &#39;None&#39; for a 0th order process are renamed to &#39;&#39;.
        if &#39;None&#39; in self.reactants.keys():
            self.reactants[&#39;&#39;] = self.reactants.pop(&#39;None&#39;)
        if &#39;None&#39; in self.products.keys():
            self.products[&#39;&#39;] = self.products.pop(&#39;None&#39;)

        self.order = sum(self.reactants.values())

        self.is_heterogeneous = False if isinstance(self.k, (int, float)) else True

        if self.order == 0:
            msg = &#34;Since a birth process does not depended on the presence of agents, &#34; \
                  &#34;heterogeneity does not make sense in this context. Please define &#34; \
                  &#34;the rate constant k as a number. &#34;
            assert not self.is_heterogeneous, msg

        # Two ways of storing the involved species:
        # 1) A set of all species
        self.species = set((self.reactants | self.products).keys())
        with contextlib.suppress(KeyError):
            self.species.remove(&#39;&#39;)  # remove empty species name from any 0th order processes

        # 2) Separate lists
        self.reacts_ = list()  # [reactant species]
        self.prods_ = list()  # [product species]
        self._get_reacts_prods_()

        &#34;&#34;&#34; Because Process objects are used as keys in dictionaries used 
        in an AbStochKin simulation, it&#39;s much faster to generate the object&#39;s 
        string representation once, and then access it whenever it&#39;s needed 
        (which could be thousands of times during a simulation). &#34;&#34;&#34;
        self._str = self.__str__().split(&#39;;&#39;)[0]

        if len(kwargs) &gt; 0:
            self._lsp(kwargs)

    def _get_reacts_prods_(self):
        &#34;&#34;&#34; Make lists of the reactant and product species. Repeated
        elements of a list reflect the order or molecularity of the
        species in the given process. For example, for the process
        `2A + B -&gt; C + D, reacts_ = [&#39;A&#39;, &#39;A&#39;, &#39;B&#39;], prods_ = [&#39;C&#39;, &#39;D&#39;]`. &#34;&#34;&#34;
        for r, m in self.reactants.items():
            for i in range(m):
                self.reacts_.append(r)

        for p, m in self.products.items():
            for i in range(m):
                self.prods_.append(p)

        if &#39;&#39; in self.reacts_:  # remove empty reactant species names
            self.reacts_.remove(&#39;&#39;)  # from 0th order processes
        if &#39;&#39; in self.prods_:  # remove empty product species names
            self.prods_.remove(&#39;&#39;)  # from degradation processes

    @classmethod
    def from_string(cls,
                    proc_str: str,
                    /,
                    k: float | int | list[float, ...] | tuple[float, float],
                    *,
                    sep: str = &#39;-&gt;&#39;,
                    **kwargs) -&gt; Self:
        &#34;&#34;&#34; Create a process from a string.

        Parameters
        ----------
        proc_str : str
            A string describing the process in standard chemical notation
            (e.g., &#39;A + B -&gt; C&#39;)
        k : float or int or list of floats or 2-tuple of floats
            The rate constant for the given process. If `k` is a float or
            int, then the process is homogeneous. If `k` is a list, then
            the population of the reactants constsists of distinct subspecies
            or subinteractions depending on the order. If `k` is a 2-tuple,
            then the constant is normally-distributed with a mean and standard
            deviation specified in the tuple&#39;s elements.
        sep : str, default: &#39;-&gt;&#39;
            Specifies the characters that distinguish the reactants from the
            products. The default is &#39;-&gt;&#39;. The code also treats `--&gt;` as a
            default, if it&#39;s present in `proc_str`.

        Notes
        -----
        - Species names should not contain spaces, dashes, and
          should start with a non-numeric character.
        - Zeroth order processes should be specified by an empty space or &#39;None&#39;.

        Examples
        --------
        &gt;&gt;&gt; Process.from_string(&#34;2A + B -&gt; X&#34;, 0.3)
        &gt;&gt;&gt; Process.from_string(&#34; -&gt; Y&#34;, 0.1)  # for a 0th order (birth) process.
        &gt;&gt;&gt; Process.from_string(&#34;Protein_X -&gt; None&#34;, 0.15)  # for a 1st order degradation process.
        &#34;&#34;&#34;

        if len(kwargs) &gt; 0:
            cls._lsp(kwargs)

        sep = &#39;--&gt;&#39; if &#39;--&gt;&#39; in proc_str else sep
        if sep not in proc_str:
            raise Exception(&#34;Cannot distinguish the reactants from the products.\n&#34;
                            &#34;Please use the *sep* keyword: e.g. sep=&#39;-&gt;&#39;.&#34;)

        lhs, rhs = proc_str.strip().split(sep)  # Left- and Right-hand sides of process
        lhs_terms = lhs.split(&#39;+&#39;)  # Separate the terms on the left-hand side
        rhs_terms = rhs.split(&#39;+&#39;)  # Separate the terms on the right-hand side

        return cls(cls._to_dict(lhs_terms), cls._to_dict(rhs_terms), k)

    @staticmethod
    def _lsp(kwargs: dict):
        &#34;&#34;&#34;
        The `Process` class accepts additional arguments (`**kwargs`).
        Since the Process class is a base class for other subclasses,
        this is done so that the Liskov Substitution Principle (LSP)
        is not violated.
        (https://en.wikipedia.org/wiki/Liskov_substitution_principle).
        This way, subclasses override the `from_string` method and have
        additional parameters while remaining consistent with this method
        from their base class. Calling the base instance with the additional
        parameters gives a warning that they will have no effect so that
        the user can intervene, if that&#39;s desired.
        &#34;&#34;&#34;
        msg = f&#34;Warning: Additional parameters {&#39;,&#39;.join([str(i) for i in kwargs.items()])} &#34; \
              f&#34;will have no effect. &#34;
        if &#39;k_rev&#39; in kwargs.keys():
            msg += f&#34;If that&#39;s not what you intended, define the process &#34; \
                   f&#34;using ReversibleProcess().&#34;
        if &#39;regulating_species&#39; in kwargs.keys() or &#39;alpha&#39; in kwargs.keys() or \
                &#39;nH&#39; in kwargs.keys() or &#39;K50&#39; in kwargs.keys():
            msg += f&#34;If that&#39;s not what you intended, define the process &#34; \
                   f&#34;using RegulatedProcess().&#34;
        if &#39;catalyst&#39; in kwargs.keys():
            msg += f&#34;If that&#39;s not what you intended, define the process &#34; \
                   f&#34;using MichaelisMentenProcess().&#34;
        print(msg)

    @staticmethod
    def _to_dict(terms: list) -&gt; dict:
        &#34;&#34;&#34; Convert the information for a side of a process to a dictionary. &#34;&#34;&#34;

        side_terms = dict()  # for storing the information of a side of a process
        patt = &#39;^[\\-]*[1-9]+&#39;  # regex pattern (accounts for leading erroneous minus sign)

        if len(terms) == 1 and terms[0].strip().lower() in [&#39;&#39;, &#39;none&#39;]:
            spec = &#39;&#39;  # Zeroth order process
            side_terms[spec] = 0
        else:
            for term in terms:
                term = term.strip()
                try:
                    match = re.search(patt, term)
                    stoic_coef = term[slice(*match.span())]  # extract stoichiometric coef
                    spec = re.split(patt, term)[-1].strip()  # extract species name
                    if spec == &#39;&#39; and stoic_coef != 0:
                        raise NullSpeciesNameError()
                    stoic_coef = int(stoic_coef)
                except AttributeError:  # when there is no specified stoichiometric coefficient
                    spec = re.split(patt, term)[-1]  # extract species name
                    stoic_coef = 1

                if spec not in side_terms.keys():
                    side_terms[spec] = stoic_coef
                else:
                    side_terms[spec] += stoic_coef

        return side_terms

    def _validate_nums(self):
        &#34;&#34;&#34; Make sure coefficients and rate constant values are not negative. &#34;&#34;&#34;
        for r, val in (self.reactants | self.products).items():
            assert val &gt;= 0, f&#34;Coefficient cannot be negative: {val} {r}.&#34;

        error_msg = f&#34;Rate constant values have to be positive: k = {self.k}.&#34;
        if isinstance(self.k, (list, tuple)):  # heterogeneous population
            assert all(array(self.k) &gt; 0), error_msg
        else:  # when k is a float or int, the population is homogeneous
            assert self.k &gt; 0, error_msg

        # For normally-distributed k values, specification is a 2-tuple.
        if isinstance(self.k, tuple):  # normal distribution of k values
            assert len(self.k) == 2, &#34;Please specify the mean and standard deviation &#34; \
                                     &#34;of k in a 2-tuple: (mean, std).&#34;

    def __eq__(self, other):
        if isinstance(other, Process):
            is_equal = (self.k == other.k and
                        self.order == other.order and
                        self.reactants == other.reactants and
                        self.products == other.products and
                        self.species == other.species)
            return is_equal
        elif isinstance(other, str):
            return self._str == other or self._str.replace(&#39; &#39;, &#39;&#39;) == other
        else:
            print(f&#34;{type(self)} and {type(other)} are instances of different classes.&#34;)
            return False

    def __hash__(self):
        return hash(self._str)

    def __contains__(self, item):
        return True if item in self.species else False

    def __repr__(self):
        return f&#34;Process Object: Process.from_string(&#39;{self._str.split(&#39;,&#39;)[0]}&#39;, k={self.k})&#34;

    def __str__(self):
        if isinstance(self.k, (float, int)):
            het_str = &#34;Homogeneous process.&#34;
        elif isinstance(self.k, list):
            het_str = f&#34;Heterogeneous process with {len(self.k)} distinct subspecies.&#34;
        else:
            het_str = f&#34;Heterogeneous process with normally-distributed k with &#34; \
                      f&#34;mean {self.k[0]} and standard deviation {self.k[1]}.&#34;

        lhs, rhs = self._reconstruct_string()
        return &#39; -&gt; &#39;.join([lhs, rhs]) + f&#39;, k = {self.k}; {het_str}&#39;

    def _reconstruct_string(self):
        lhs = &#39; + &#39;.join([f&#34;{str(val) + &#39; &#39; if val not in [0, 1] else &#39;&#39;}{key}&#34; for key, val in
                          self.reactants.items()])
        rhs = &#39; + &#39;.join([f&#34;{str(val) + &#39; &#39; if val not in [0, 1] else &#39;&#39;}{key}&#34; for key, val in
                          self.products.items()])
        return lhs, rhs


class ReversibleProcess(Process):
    &#34;&#34;&#34; Define a reversible process.

    Attributes
    ----------
    k_rev : float or int or list of floats or 2-tuple of floats
        The *microscopic* rate constant for the reverse process.
    is_heterogeneous_rev : bool
        Denotes if the parameter `k_rev` exhibits heterogeneity
        (distinct subspecies/interactions or normally-distributed).

    Notes
    -----
    A ReversibleProcess object gets split into two Process objects
    (forward and reverse process) when the algorithm runs.
    &#34;&#34;&#34;

    def __init__(self, reactants: dict, products: dict,
                 k: float | int | list[float, ...] | tuple[float, float],
                 k_rev: float | int | list[float, ...] | tuple[float, float]):
        self.k_rev = k_rev  # rate constant for reverse process
        self.is_heterogeneous_rev = False if isinstance(self.k_rev, (int, float)) else True

        super().__init__(reactants, products, k)

        self.order_rev = sum(self.products.values())

    @classmethod
    def from_string(cls,
                    proc_str: str,
                    /,
                    k: float | int | list[float, ...] | tuple[float, float],
                    *,
                    k_rev: float | int | list[float, ...] | tuple[float, float] = 0,
                    sep: str = &#39;&lt;-&gt;&#39;) -&gt; Self:
        &#34;&#34;&#34; Create a reversible process from a string.

        Parameters
        ----------
        proc_str : str
            A string describing the process in standard chemical notation
            (e.g., &#39;A + B &lt;-&gt; C&#39;)
        k : float or int or list of floats or 2-tuple of floats
            The *microscopic* rate constant for the forward process.
        k_rev : float or int or list of floats or 2-tuple of floats
            The *microscopic* rate constant for the reverse process.
        sep : str, default: &#39;&lt;-&gt;&#39;
            Specifies the characters that distinguish the reactants from the
            products. The default is &#39;&lt;-&gt;&#39;. The code also treats `&lt;--&gt;` as a
            default, if it&#39;s present in `proc_str`.

        Notes
        -----
        - Species names should not contain spaces, dashes, and
          should start with a non-numeric character.

        Examples
        --------
        &gt;&gt;&gt; ReversibleProcess.from_string(&#34;2A + B &lt;-&gt; X&#34;, 0.3, k_rev=0.2)
        &#34;&#34;&#34;
        for s in [&#39;&lt;--&gt;&#39;, &#39;&lt;=&gt;&#39;, &#39;&lt;==&gt;&#39;]:
            sep = s if s in proc_str else sep
        if sep not in proc_str:
            raise Exception(&#34;Cannot distinguish the reactants from the products.\n&#34;
                            &#34;Please use the *sep* keyword: e.g. sep=&#39;&lt;-&gt;&#39;.&#34;)

        lhs, rhs = proc_str.strip().split(sep)  # Left- and Right-hand sides of process
        lhs_terms = lhs.split(&#39;+&#39;)  # Separate the terms on the left-hand side
        rhs_terms = rhs.split(&#39;+&#39;)  # Separate the terms on the right-hand side

        return cls(cls._to_dict(lhs_terms), cls._to_dict(rhs_terms),
                   k, k_rev)

    def __repr__(self):
        return f&#34;ReversibleProcess Object: ReversibleProcess.from_string(&#34; \
               f&#34;&#39;{self._str.split(&#39;,&#39;)[0]}&#39;, k={self.k}, k_rev={self.k_rev})&#34;

    def __str__(self):
        if isinstance(self.k, (float, int)):
            het_str = &#34;Forward homogeneous process.&#34;
        elif isinstance(self.k, list):
            het_str = f&#34;Forward heterogeneous process with {len(self.k)} &#34; \
                      f&#34;distinct subspecies.&#34;
        else:
            het_str = f&#34;Forward heterogeneous process with normally-distributed &#34; \
                      f&#34;k with mean {self.k[0]} and standard deviation {self.k[1]}.&#34;

        if isinstance(self.k_rev, (float, int)):
            het_rev_str = &#34;Reverse homogeneous process.&#34;
        elif isinstance(self.k_rev, list):
            het_rev_str = f&#34;Reverse heterogeneous process with {len(self.k_rev)} &#34; \
                          f&#34;distinct subspecies.&#34;
        else:
            het_rev_str = f&#34;Reverse heterogeneous process with normally-distributed &#34; \
                          f&#34;k with mean {self.k_rev[0]} and standard deviation {self.k_rev[1]}.&#34;

        lhs, rhs = self._reconstruct_string()
        return &#34; &lt;-&gt; &#34;.join([lhs, rhs]) + f&#34;, k = {self.k}, k_rev = {self.k_rev}; &#34; \
                                          f&#34;{het_str} {het_rev_str}&#34;

    def _reconstruct_string(self):
        lhs = &#39; + &#39;.join([f&#34;{str(val) + &#39; &#39; if val not in [0, 1] else &#39;&#39;}{key}&#34; for key, val in
                          self.reactants.items()])
        rhs = &#39; + &#39;.join([f&#34;{str(val) + &#39; &#39; if val not in [0, 1] else &#39;&#39;}{key}&#34; for key, val in
                          self.products.items()])
        return lhs, rhs

    def __eq__(self, other):
        if isinstance(other, ReversibleProcess):
            is_equal = (self.k == other.k and
                        self.order == other.order and
                        self.k_rev == other.k_rev and
                        self.order_rev == other.order_rev and
                        self.reactants == other.reactants and
                        self.products == other.products and
                        self.species == other.species)
            return is_equal
        elif isinstance(other, str):
            return self._str == other or self._str.replace(&#39; &#39;, &#39;&#39;) == other
        else:
            print(f&#34;{type(self)} and {type(other)} are instances of different classes.&#34;)
            return False

    def __hash__(self):
        return hash(self._str)


class MichaelisMentenProcess(Process):
    &#34;&#34;&#34; Define a process that obeys Michaelis-Menten kinetics.

    Attributes
    ----------
    catalyst : str
        Name of the species acting as a catalyst for this process.
    Km : float or int or list of floats or 2-tuple of floats
        *Microscopic* Michaelis constant. Corresponds to the number
        of `catalyst` agents that would produce half-maximal activity.
        Heterogeneity in this parameter is determined by the type of `K50`,
        using the same rules as for parameter `k`.
    is_heterogeneous_Km : bool
        Denotes if the parameter `Km` exhibits heterogeneity
        (distinct subspecies/interactions or normally-distributed).
    &#34;&#34;&#34;

    def __init__(self, reactants: dict, products: dict,
                 k: float | int | list[float | int, ...] | tuple[float | int, float | int],
                 catalyst: str,
                 Km: float | int | list[float | int, ...] | tuple[float | int, float | int]):
        self.catalyst = catalyst
        self.Km = Km
        self.is_heterogeneous_Km = False if isinstance(self.Km, (int, float)) else True

        super().__init__(reactants, products, k)

        self.species.add(self.catalyst)
        self._str += f&#34;, catalyst = {self.catalyst}, Km = {self.Km}&#34;

        assert self.order != 0, &#34;A 0th order process has no substrate for a catalyst &#34; \
                                &#34;to act on, therefore it cannot follow Michaelis-Menten kinetics.&#34;
        if self.order == 2:
            raise NotImplementedError

    @classmethod
    def from_string(cls,
                    proc_str: str,
                    /,
                    k: float | int | list[float | int, ...] | tuple[float | int, float | int],
                    *,
                    catalyst: str = None,
                    Km: float | int | list[float | int, ...] | tuple[
                        float | int, float | int] = None,
                    sep: str = &#39;-&gt;&#39;) -&gt; Self:
        &#34;&#34;&#34; Create a Michaelis-Menten process from a string.

        Parameters
        ----------
        proc_str : str
            A string describing the process in standard chemical notation
            (e.g., &#39;A + B -&gt; C&#39;)
        k : float or int or list of floats or 2-tuple of floats
            The *microscopic* rate constant for the given process. If `k` is a
            float or int, then the process is homogeneous. If `k` is a list, then
            the population of the reactants constsists of distinct subspecies
            or subinteractions depending on the order. If `k` is a 2-tuple,
            then the constant is normally-distributed with a mean and standard
            deviation specified in the tuple&#39;s elements.
        catalyst : str
            Name of species acting as a catalyst.
        Km : float or int or list of floats or 2-tuple of floats
            *Microscopic* Michaelis constant for the process.
            Heterogeneity in this parameter is determined by the type of `Km`,
            using the same rules as for parameter `k`.
        sep : str, default: &#39;-&gt;&#39;
            Specifies the characters that distinguish the reactants from the
            products. The default is &#39;-&gt;&#39;. The code also treats `--&gt;` as a
            default, if it&#39;s present in `proc_str`.

        Notes
        -----
        - Species names should not contain spaces, dashes, and
          should start with a non-numeric character.
        - Zeroth order processes should be specified by an empty space or &#39;None&#39;.

        Examples
        --------
        &gt;&gt;&gt; MichaelisMentenProcess.from_string(&#34;A -&gt; X&#34;, k=0.3, catalyst=&#39;E&#39;, Km=10)
        &gt;&gt;&gt; MichaelisMentenProcess.from_string(&#34;A -&gt; X&#34;, k=0.3, catalyst=&#39;alpha&#39;, Km=(10, 1))
        &#34;&#34;&#34;
        sep = &#39;--&gt;&#39; if &#39;--&gt;&#39; in proc_str else sep
        if sep not in proc_str:
            raise Exception(&#34;Cannot distinguish the reactants from the products.\n&#34;
                            &#34;Please use the *sep* keyword: e.g. sep=&#39;-&gt;&#39;.&#34;)

        lhs, rhs = proc_str.strip().split(sep)  # Left- and Right-hand sides of process
        lhs_terms = lhs.split(&#39;+&#39;)  # Separate the terms on the left-hand side
        rhs_terms = rhs.split(&#39;+&#39;)  # Separate the terms on the right-hand side

        return cls(cls._to_dict(lhs_terms), cls._to_dict(rhs_terms),
                   k,
                   catalyst, Km)

    def __str__(self):
        if isinstance(self.Km, (float, int)):
            Km_het_str = &#34;Homogeneous process with respect to Km.&#34;
        elif isinstance(self.k, list):
            Km_het_str = f&#34;Heterogeneous process with respect to Km &#34; \
                         f&#34;with {len(self.Km)} distinct subspecies.&#34;
        else:
            Km_het_str = f&#34;Heterogeneous process with normally-distributed Km with &#34; \
                         f&#34;mean {self.Km[0]} and standard deviation {self.Km[1]}.&#34;

        return super().__str__() + f&#34; Catalyst: {self.catalyst}, &#34; \
                                   f&#34;Km = {self.Km}, {Km_het_str}&#34;

    def __repr__(self):
        return f&#34;MichaelisMentenProcess Object: &#34; \
               f&#34;MichaelisMentenProcess.from_string(&#39;{self._str.split(&#39;,&#39;)[0]}&#39;, &#34; \
               f&#34;k={self.k}, &#34; \
               f&#34;catalyst=&#39;{self.catalyst}&#39;, &#34; \
               f&#34;Km={self.Km})&#34;

    def __eq__(self, other):
        if isinstance(other, MichaelisMentenProcess):
            is_equal = (self.k == other.k and
                        self.order == other.order and
                        self.reactants == other.reactants and
                        self.products == other.products and
                        self.catalyst == other.catalyst and
                        self.Km == other.Km and
                        self.species == other.species)
            return is_equal
        elif isinstance(other, str):
            return self._str == other or self._str.replace(&#39; &#39;, &#39;&#39;) == other
        else:
            print(f&#34;{type(self)} and {type(other)} are instances of different classes.&#34;)
            return False

    def __hash__(self):
        return hash(self._str)


class RegulatedProcess(Process):
    &#34;&#34;&#34; Define a process that is regulated.

    This class allows a Process to be defined in terms of how it is regulated.
    If there is only one regulating species, then the parameters have the same
    type as would be expected for a homogeneous/heterogeneous process.
    If there are multiple regulating species, then all parameters are a list
    of their expected type, with the length of the list being equal to the
    number of regulating species.
    
    Attributes
    ----------
    k : float or int or list of floats or 2-tuple of floats
        The *microscopic* rate constant for the given process. It is the *basal*
        rate constant in the case of activation (or the minimum `k` value)
        and the maximum rate constant in the case of repression.
    regulating_species : str or list of str
        Name of the regulating species. Multiple species can be specified as
        comma-separated in a string or a list of strings with the species names.
    alpha : float or int or list[float or int]
        Parameter denoting the degree of activation/repression.

            - 0 &lt;= alpha &lt; 1: repression
            - alpha = 1: no regulation
            - alpha &gt; 1: activation
            
        alpha is a multiplier: in the case of activation, the maximum 
        rate constant value will be `alpha * k`. 
        In the case of repression, the minimum 
        rate constant value will be `alpha * k`. 
    K50 : float or int or list of floats or 2-tuple of floats or list[float or int or list of floats or 2-tuple of floats]
        *Microscopic* constant that corresponds to the number of
        `regulating_species` agents that would produce 
        half-maximal activation/repression. 
        Heterogeneity in this parameter is determined by the type of `K50`,
        using the same rules as for parameter `k`.
    nH : float or int or list[float or int]
        Hill coefficient for the given process. Indicates the degree of 
        cooperativity in the regulatory interaction. 
    is_heterogeneous_K50 : bool or list of bool
        Denotes if the parameter `K50` exhibits heterogeneity
        (distinct subspecies/interactions or normally-distributed).
    regulation_type : str or list of str
        The type of regulation for this process based on the value of alpha:
        &#39;activation&#39; or &#39;repression&#39; or &#39;no regulation&#39;.

    Notes
    -----
    Allowing a 0th order process to be regulated. However, heterogeneity
    in `k` and `K50` (or any other parameters) is not allowed for such
    a process.
    &#34;&#34;&#34;

    def __init__(self, reactants: dict, products: dict,
                 k: float | int | list[float, ...] | tuple[float, float],
                 regulating_species: str | list[str, ...],
                 alpha: float | int | list[float | int, ...],
                 K50: float | int | list[float | int, ...] | tuple[float | int, float | int] |
                      list[float | int | list[float | int, ...] | tuple[float | int, float | int]],
                 nH: float | int | list[float | int, ...]):
        if isinstance(regulating_species, str):
            reg_sp_list = regulating_species.replace(&#39; &#39;, &#39;&#39;).split(&#39;,&#39;)
            self.regulating_species = reg_sp_list[0] if len(reg_sp_list) == 1 else reg_sp_list
        else:  # if it is a list
            self.regulating_species = regulating_species

        self.alpha = alpha
        self.K50 = K50
        self.nH = nH

        if isinstance(K50, list):
            self.is_heterogeneous_K50 = [False if isinstance(val, (int, float)) else True for val
                                         in K50]
        else:
            self.is_heterogeneous_K50 = False if isinstance(self.K50, (int, float)) else True

        super().__init__(reactants, products, k)

        self._str += f&#34;, regulating_species = {self.regulating_species}, alpha = {self.alpha}, &#34; \
                     f&#34;K50 = {self.K50}, nH = {self.nH}&#34;

        self._validate_reg_params()

        if isinstance(self.alpha, list):
            self.regulation_type = list()
            for a in self.alpha:
                reg_type = &#39;activation&#39; if a &gt; 1 else &#39;repression&#39; if a &lt; 1 else &#39;no regulation&#39;
                self.regulation_type.append(reg_type)
        else:
            self.regulation_type = &#39;activation&#39; if self.alpha &gt; 1 else &#39;repression&#39; if self.alpha &lt; 1 else &#39;no regulation&#39;

    def _validate_reg_params(self):
        &#34;&#34;&#34; Validate the parameters specific to the regulation. &#34;&#34;&#34;
        if isinstance(self.regulating_species, list):  # multiple regulating species
            # First check that the right number of values for each parameter are specified
            rs_num = len(self.regulating_species)
            msg = f&#34;Must specify {rs_num} # values when there are {rs_num} regulating species.&#34;
            assert len(self.alpha) == rs_num, msg.replace(&#39;#&#39;, &#39;alpha&#39;)
            assert len(self.K50) == rs_num, msg.replace(&#39;#&#39;, &#39;K50&#39;)
            assert len(self.nH) == rs_num, msg.replace(&#39;#&#39;, &#39;nH&#39;)

            for i in range(len(self.regulating_species)):
                assert self.alpha[i] &gt;= 0, &#34;The alpha parameter must be nonnegative.&#34;
                if self.alpha[i] == 1:
                    print(&#34;Warning: alpha=1 means the process is not regulated.&#34;)

                if isinstance(self.K50[i], (float, int)):
                    assert self.K50[i] &gt; 0, &#34;K50 has to be positive.&#34;
                elif isinstance(self.K50[i], list):
                    assert all([True if val &gt; 0 else False for val in self.K50[i]]), \
                        &#34;Subspecies K50 values have to be positive.&#34;
                else:  # isinstance(self.K50, tuple)
                    assert self.K50[i][0] &gt; 0 and self.K50[i][1] &gt; 0, \
                        &#34;Mean and std of K50 have to be positive.&#34;

                if self.order == 0:
                    assert not self.is_heterogeneous_K50[i], \
                        &#34;Heterogeneity in parameter K50 is not allowed for a 0th order process.&#34;

                assert self.nH[i] &gt; 0, &#34;nH has to be positive.&#34;

        else:  # just one regulating species
            assert self.alpha &gt;= 0, &#34;The alpha parameter must be nonnegative.&#34;
            if self.alpha == 1:
                print(&#34;Warning: alpha=1 means the process is not regulated.&#34;)

            if isinstance(self.K50, (float, int)):
                assert self.K50 &gt; 0, &#34;K50 has to be positive.&#34;
            elif isinstance(self.K50, list):
                assert all([True if val &gt; 0 else False for val in self.K50]), \
                    &#34;Subspecies K50 values have to be positive.&#34;
            else:  # isinstance(self.K50, tuple)
                assert self.K50[0] &gt; 0 and self.K50[1] &gt; 0, \
                    &#34;Mean and std of K50 have to be positive.&#34;

            if self.order == 0:
                assert not self.is_heterogeneous_K50, \
                    &#34;Heterogeneity in parameter K50 is not allowed for a 0th order process.&#34;

            assert self.nH &gt; 0, &#34;nH has to be positive.&#34;

    @classmethod
    def from_string(cls,
                    proc_str: str,
                    /,
                    k: float | int | list[float, ...] | tuple[float, float],
                    *,
                    regulating_species: str | list[str, ...] = None,
                    alpha: float | int | list[float | int, ...] = 1,
                    K50: float | int | list[float | int, ...] | tuple[float | int, float | int] |
                         list[float | int | list[float | int, ...] | tuple[
                             float | int, float | int]] = None,
                    nH: float | int | list[float | int, ...] = None,
                    sep: str = &#39;-&gt;&#39;) -&gt; Self:
        &#34;&#34;&#34; Create a regulated process from a string.

        Parameters
        ----------
        proc_str : str
            A string describing the process in standard chemical notation
            (e.g., &#39;A + B -&gt; C&#39;)
        k : float or int or list of floats or 2-tuple of floats
            The *microscopic* rate constant for the given process. It is the *basal*
            rate constant in the case of activation (or the minimum `k` value) 
            and the maximum rate constant in the case of repression. 
            If `k` is a float or int, then the process is homogeneous. 
            If `k` is a list, then the population of the reactants 
            constsists of distinct subspecies or subinteractions 
            depending on the order. If `k` is a 2-tuple,
            then the constant is normally-distributed with a mean and standard
            deviation specified in the tuple&#39;s elements. Note that `k` cannot
            be zero for this form of regulation.
        regulating_species : str or list of str
            Name of the regulating species.
        alpha : float or int or list[float or int]
            Parameter denoting the degree of activation/repression.

                - 0 &lt;= alpha &lt; 1: repression
                - alpha = 1: no regulation
                - alpha &gt; 1: activation
                
            alpha is a multiplier: in the case of activation, the maximum 
            rate constant value will be `alpha * k`. 
            In the case of repression, the minimum 
            rate constant value will be `alpha * k`. 
        K50 : float or int or list of floats or 2-tuple of floats or list of each of the previous types
            *Microscopic* constant that corresponds to the number of
            `regulating_species` agents that would produce 
            half-maximal activation/repression. 
            Heterogeneity in this parameter is determined by the type of `K50`,
            using the same rules as for parameter `k`.
        nH : float or int or list[float or int]
            Hill coefficient for the given process. Indicates the degree of 
            cooperativity in the regulatory interaction. 
        sep : str, default: &#39;-&gt;&#39;
            Specifies the characters that distinguish the reactants from the
            products. The default is &#39;-&gt;&#39;. The code also treats `--&gt;` as a
            default, if it&#39;s present in `proc_str`.

        Notes
        -----
        - Species names should not contain spaces, dashes, and
          should start with a non-numeric character.
        - Zeroth order processes should be specified by an empty space or &#39;None&#39;.

        Examples
        --------
        &gt;&gt;&gt; RegulatedProcess.from_string(&#34;A -&gt; X&#34;, k=0.2, regulating_species=&#39;X&#39;, alpha=2, K50=10, nH=1)
        &gt;&gt;&gt; RegulatedProcess.from_string(&#34;A -&gt; X&#34;, k=0.3, regulating_species=&#39;X&#39;, alpha=0.5, K50=[10, 15], nH=2)
        &gt;&gt;&gt; RegulatedProcess.from_string(&#34;A + B -&gt; X&#34;, k=0.5, regulating_species=&#39;B, X&#39;, alpha=[2, 0], K50=[(15, 5), [10, 15]], nH=[1, 2])
        &#34;&#34;&#34;
        sep = &#39;--&gt;&#39; if &#39;--&gt;&#39; in proc_str else sep
        if sep not in proc_str:
            raise Exception(&#34;Cannot distinguish the reactants from the products.\n&#34;
                            &#34;Please use the *sep* keyword: e.g. sep=&#39;-&gt;&#39;.&#34;)

        lhs, rhs = proc_str.strip().split(sep)  # Left- and Right-hand sides of process
        lhs_terms = lhs.split(&#39;+&#39;)  # Separate the terms on the left-hand side
        rhs_terms = rhs.split(&#39;+&#39;)  # Separate the terms on the right-hand side

        return cls(cls._to_dict(lhs_terms), cls._to_dict(rhs_terms),
                   k,
                   regulating_species, alpha, K50, nH)

    def __str__(self):
        if isinstance(self.regulating_species, list):
            K50_het_str = &#34;&#34;
            for i, sp in enumerate(self.regulating_species):
                if isinstance(self.K50[i], (float, int)):
                    K50_het_str += f&#34;Homogeneous process with respect to species {sp} K50. &#34;
                elif isinstance(self.K50[i], list):
                    K50_het_str += f&#34;Heterogeneous process with respect to species {sp} K50 &#34; \
                                   f&#34;with {len(self.K50[i])} distinct subspecies. &#34;
                else:
                    K50_het_str += f&#34;Heterogeneous process with normally-distributed &#34; \
                                   f&#34;species {sp} K50 with mean {self.K50[i][0]} and &#34; \
                                   f&#34;standard deviation {self.K50[i][1]}. &#34;
        else:
            if isinstance(self.K50, (float, int)):
                K50_het_str = &#34;Homogeneous process with respect to K50.&#34;
            elif isinstance(self.K50, list):
                K50_het_str = f&#34;Heterogeneous process with respect to K50 &#34; \
                              f&#34;with {len(self.K50)} distinct subspecies.&#34;
            else:
                K50_het_str = f&#34;Heterogeneous process with normally-distributed K50 with &#34; \
                              f&#34;mean {self.K50[0]} and standard deviation {self.K50[1]}.&#34;

        return super().__str__() + f&#34; Regulating Species: {self.regulating_species}, &#34; \
                                   f&#34;alpha = {self.alpha}, nH = {self.nH}, &#34; \
                                   f&#34;K50 = {self.K50}, {K50_het_str}&#34;

    def __repr__(self):
        return f&#34;RegulatedProcess Object: &#34; \
               f&#34;RegulatedProcess.from_string(&#39;{self._str.split(&#39;,&#39;)[0]}&#39;, &#34; \
               f&#34;k={self.k}, &#34; \
               f&#34;regulating_species=&#39;{self.regulating_species}&#39;, &#34; \
               f&#34;alpha={self.alpha}, &#34; \
               f&#34;K50={self.K50}, &#34; \
               f&#34;nH={self.nH})&#34;

    def __eq__(self, other):
        if isinstance(other, RegulatedProcess):
            is_equal = (self.k == other.k and
                        self.order == other.order and
                        self.reactants == other.reactants and
                        self.products == other.products and
                        self.regulating_species == other.regulating_species and
                        self.alpha == other.alpha and
                        self.K50 == other.K50 and
                        self.nH == other.nH and
                        self.species == other.species)
            return is_equal
        elif isinstance(other, str):
            return self._str == other or self._str.replace(&#39; &#39;, &#39;&#39;) == other
        else:
            print(f&#34;{type(self)} and {type(other)} are instances of different classes.&#34;)
            return False

    def __hash__(self):
        return hash(self._str)


class RegulatedMichaelisMentenProcess(RegulatedProcess):
    &#34;&#34;&#34; Define a process that is regulated and obeys Michaelis-Menten kinetics.

    This class allows a Michaelis-Menten Process to be defined
    in terms of how it is regulated.
    If there is only one regulating species, then the parameters have the same
    type as would be expected for a homogeneous/heterogeneous process.
    If there are multiple regulating species, then all parameters are a list
    of their expected type, with the length of the list being equal to the
    number of regulating species.

    Attributes
    ----------
    k : float or int or list of floats or 2-tuple of floats
        The *microscopic* rate constant for the given process. It is the *basal*
        rate constant in the case of activation (or the minimum `k` value)
        and the maximum rate constant in the case of repression.
    regulating_species : str or list of str
        Name of the regulating species. Multiple species can be specified as
        comma-separated in a string or a list of strings with the species names.
    alpha : float or int or list[float or int]
        Parameter denoting the degree of activation/repression.

            - 0 &lt;= alpha &lt; 1: repression
            - alpha = 1: no regulation
            - alpha &gt; 1: activation

        alpha is a multiplier: in the case of activation, the maximum
        rate constant value will be `alpha * k`.
        In the case of repression, the minimum
        rate constant value will be `alpha * k`.
    K50 : float or int or list of floats or 2-tuple of floats or list[float or int or list of floats or 2-tuple of floats]
        *Microscopic* constant that corresponds to the number of
        `regulating_species` agents that would produce
        half-maximal activation/repression.
        Heterogeneity in this parameter is determined by the type of `K50`,
        using the same rules as for parameter `k`.
    nH : float or int or list[float or int]
        Hill coefficient for the given process. Indicates the degree of
        cooperativity in the regulatory interaction.
    is_heterogeneous_K50 : bool or list of bool
        Denotes if the parameter `K50` exhibits heterogeneity
        (distinct subspecies/interactions or normally-distributed).
    regulation_type : str or list of str
        The type of regulation for this process based on the value of alpha:
        &#39;activation&#39; or &#39;repression&#39; or &#39;no regulation&#39;.
    catalyst : str
        Name of the species acting as a catalyst for this process.
    Km : float or int or list of floats or 2-tuple of floats
        *Microscopic* Michaelis constant. Corresponds to the number
        of `catalyst` agents that would produce half-maximal activity.
        Heterogeneity in this parameter is determined by the type of `K50`,
        using the same rules as for parameter `k`.
    is_heterogeneous_Km : bool
        Denotes if the parameter `Km` exhibits heterogeneity
        (distinct subspecies/interactions or normally-distributed).

    Notes
    -----
    Currently only implemented for 1st order processes. 0th order processes
    cannot obey Michaelis-Menten kinetics and 2nd order Michaelis-Menten
    processes are not implemented yet.
    &#34;&#34;&#34;

    def __init__(self, reactants: dict, products: dict,
                 k: float | int | list[float, ...] | tuple[float, float],
                 regulating_species: str | list[str, ...],
                 alpha: float | int | list[float | int, ...],
                 K50: float | int | list[float | int, ...] | tuple[float | int, float | int] |
                      list[float | int | list[float | int, ...] | tuple[float | int, float | int]],
                 nH: float | int | list[float | int, ...],
                 catalyst: str,
                 Km: float | int | list[float | int, ...] | tuple[float | int, float | int]):
        self.catalyst = catalyst
        self.Km = Km
        self.is_heterogeneous_Km = False if isinstance(self.Km, (int, float)) else True

        super().__init__(reactants, products, k, regulating_species, alpha, K50, nH)

        self.species.add(self.catalyst)
        self._str += f&#34;, catalyst = {self.catalyst}, Km = {self.Km}&#34;

        assert self.order != 0, &#34;A 0th order process has no substrate for a catalyst &#34; \
                                &#34;to act on, therefore it cannot follow Michaelis-Menten kinetics.&#34;
        if self.order == 2:
            raise NotImplementedError

    @classmethod
    def from_string(cls,
                    proc_str: str,
                    /,
                    k: float | int | list[float, ...] | tuple[float, float],
                    *,
                    regulating_species: str | list[str, ...] = None,
                    alpha: float | int | list[float | int, ...] = 1,
                    K50: float | int | list[float | int, ...] | tuple[float | int, float | int] |
                         list[float | int | list[float | int, ...] | tuple[
                             float | int, float | int]] = None,
                    nH: float | int | list[float | int, ...] = None,
                    catalyst: str = None,
                    Km: float | int | list[float | int, ...] | tuple[
                        float | int, float | int] = None,
                    sep: str = &#39;-&gt;&#39;) -&gt; Self:
        &#34;&#34;&#34; Create a regulated Michaelis-Menten process from a string.

        Parameters
        ----------
        proc_str : str
            A string describing the process in standard chemical notation
            (e.g., &#39;A + B -&gt; C&#39;)
        k : float or int or list of floats or 2-tuple of floats
            The *microscopic* rate constant for the given process. It is the *basal*
            rate constant in the case of activation (or the minimum `k` value)
            and the maximum rate constant in the case of repression.
            If `k` is a float or int, then the process is homogeneous.
            If `k` is a list, then the population of the reactants
            constsists of distinct subspecies or subinteractions
            depending on the order. If `k` is a 2-tuple,
            then the constant is normally-distributed with a mean and standard
            deviation specified in the tuple&#39;s elements. Note that `k` cannot
            be zero for this form of regulation.
        regulating_species : str or list of str
            Name of the regulating species.
        alpha : float or int or list[float or int]
            Parameter denoting the degree of activation/repression.

            - 0 &lt;= alpha &lt; 1: repression
            - alpha = 1: no regulation
            - alpha &gt; 1: activation

            alpha is a multiplier: in the case of activation, the maximum
            rate constant value will be `alpha * k`.
            In the case of repression, the minimum
            rate constant value will be `alpha * k`.
        K50 : float or int or list of floats or 2-tuple of floats or list of each of the previous types
            *Microscopic* constant that corresponds to the number of
            `regulating_species` agents that would produce
            half-maximal activation/repression.
            Heterogeneity in this parameter is determined by the type of `K50`,
            using the same rules as for parameter `k`.
        nH : float or int or list[float or int]
            Hill coefficient for the given process. Indicates the degree of
            cooperativity in the regulatory interaction.
        catalyst : str
            Name of species acting as a catalyst.
        Km : float or int or list of floats or 2-tuple of floats
            *Microscopic* Michaelis constant for the process.
            Heterogeneity in this parameter is determined by the type of `Km`,
            using the same rules as for parameter `k`.
        sep : str, default: &#39;-&gt;&#39;
            Specifies the characters that distinguish the reactants from the
            products. The default is &#39;-&gt;&#39;. The code also treats `--&gt;` as a
            default, if it&#39;s present in `proc_str`.

        Notes
        -----
        - Species names should not contain spaces, dashes, and
          should start with a non-numeric character.
        - Zeroth order processes should be specified by an empty space or &#39;None&#39;.

        Examples
        --------
        &gt;&gt;&gt; RegulatedMichaelisMentenProcess.from_string(&#34;A -&gt; X&#34;, k=0.2, regulating_species=&#39;X&#39;, alpha=2, K50=10, nH=1, catalyst=&#39;E&#39;, Km=15)
        &gt;&gt;&gt; RegulatedMichaelisMentenProcess.from_string(&#34;A -&gt; X&#34;, k=0.3, regulating_species=&#39;A&#39;, alpha=0.5, K50=[10, 15], nH=2, catalyst=&#39;C&#39;, Km=5)
        &#34;&#34;&#34;
        sep = &#39;--&gt;&#39; if &#39;--&gt;&#39; in proc_str else sep
        if sep not in proc_str:
            raise Exception(&#34;Cannot distinguish the reactants from the products.\n&#34;
                            &#34;Please use the *sep* keyword: e.g. sep=&#39;-&gt;&#39;.&#34;)

        lhs, rhs = proc_str.strip().split(sep)  # Left- and Right-hand sides of process
        lhs_terms = lhs.split(&#39;+&#39;)  # Separate the terms on the left-hand side
        rhs_terms = rhs.split(&#39;+&#39;)  # Separate the terms on the right-hand side

        return cls(cls._to_dict(lhs_terms), cls._to_dict(rhs_terms),
                   k,
                   regulating_species, alpha, K50, nH,
                   catalyst, Km)

    def __str__(self):
        if isinstance(self.regulating_species, list):
            K50_het_str = &#34;&#34;
            for i, sp in enumerate(self.regulating_species):
                if isinstance(self.K50[i], (float, int)):
                    K50_het_str += f&#34;Homogeneous process with respect to species {sp} K50. &#34;
                elif isinstance(self.K50[i], list):
                    K50_het_str += f&#34;Heterogeneous process with respect to species {sp} K50 &#34; \
                                   f&#34;with {len(self.K50[i])} distinct subspecies. &#34;
                else:
                    K50_het_str += f&#34;Heterogeneous process with normally-distributed &#34; \
                                   f&#34;species {sp} K50 with mean {self.K50[i][0]} and &#34; \
                                   f&#34;standard deviation {self.K50[i][1]}. &#34;
        else:
            if isinstance(self.K50, (float, int)):
                K50_het_str = &#34;Homogeneous process with respect to K50.&#34;
            elif isinstance(self.K50, list):
                K50_het_str = f&#34;Heterogeneous process with respect to K50 &#34; \
                              f&#34;with {len(self.K50)} distinct subspecies.&#34;
            else:
                K50_het_str = f&#34;Heterogeneous process with normally-distributed K50 with &#34; \
                              f&#34;mean {self.K50[0]} and standard deviation {self.K50[1]}.&#34;

        if isinstance(self.Km, (float, int)):
            Km_het_str = &#34;Homogeneous process with respect to Km.&#34;
        elif isinstance(self.k, list):
            Km_het_str = f&#34;Heterogeneous process with respect to Km &#34; \
                         f&#34;with {len(self.Km)} distinct subspecies.&#34;
        else:
            Km_het_str = f&#34;Heterogeneous process with normally-distributed Km with &#34; \
                         f&#34;mean {self.Km[0]} and standard deviation {self.Km[1]}.&#34;

        return super().__str__() + f&#34; Regulating Species: {self.regulating_species}, &#34; \
                                   f&#34;alpha = {self.alpha}, nH = {self.nH}, &#34; \
                                   f&#34;K50 = {self.K50}, {K50_het_str}, &#34; \
                                   f&#34;Catalyst: {self.catalyst}, &#34; \
                                   f&#34;Km = {self.Km}, {Km_het_str}&#34;

    def __repr__(self):
        return f&#34;RegulatedMichaelisMentenProcess Object: &#34; \
               f&#34;RegulatedMichaelisMentenProcess.from_string(&#39;{self._str.split(&#39;,&#39;)[0]}&#39;, &#34; \
               f&#34;k={self.k}, &#34; \
               f&#34;regulating_species=&#39;{self.regulating_species}&#39;, &#34; \
               f&#34;alpha={self.alpha}, &#34; \
               f&#34;K50={self.K50}, &#34; \
               f&#34;nH={self.nH}, &#34; \
               f&#34;catalyst={self.catalyst}, &#34; \
               f&#34;Km={self.Km})&#34;

    def __eq__(self, other):
        if isinstance(other, RegulatedMichaelisMentenProcess):
            is_equal = (self.k == other.k and
                        self.order == other.order and
                        self.reactants == other.reactants and
                        self.products == other.products and
                        self.regulating_species == other.regulating_species and
                        self.alpha == other.alpha and
                        self.K50 == other.K50 and
                        self.nH == other.nH and
                        self.catalyst == other.catalyst and
                        self.Km == other.Km and
                        self.species == other.species)
            return is_equal
        elif isinstance(other, str):
            return self._str == other or self._str.replace(&#39; &#39;, &#39;&#39;) == other
        else:
            print(f&#34;{type(self)} and {type(other)} are instances of different classes.&#34;)
            return False

    def __hash__(self):
        return hash(self._str)


class NullSpeciesNameError(Exception):
    &#34;&#34;&#34; Error when the species name is an empty string. &#34;&#34;&#34;

    def __str__(self):
        return &#34;A species name cannot be an empty string.&#34;


def update_all_species(procs: tuple[Process, ...]) -&gt; tuple[set, dict, dict]:
    &#34;&#34;&#34; Categorize all species in a list of processes.

    Extract all species from a list of processes. Then categorize each of them
    as a reactant or product and list the process(es) it takes part in.

    Parameters
    ----------
    procs : tuple
        A tuple of objects of type `Process` or its subclasses.

    Returns
    -------
    tuple
        all_species : set of strings
            A set of all species present in the processes.
        procs_by_reactant : dict
            A dictionary whose keys are the species that are
            reactants in one or more processes. The value for each
            key is a list of processes.
        procs_by_product : dict
            A dictionary whose keys are the species that are
            products in one or more processes. The value for each
            key is a list of processes.
    &#34;&#34;&#34;
    procs = list(procs)
    for proc in procs:
        # For a reversible process, replace it with separate instances
        # of Process objects representing the forward and reverse reactions.
        if isinstance(proc, ReversibleProcess):
            forward_proc = Process(proc.reactants, proc.products, proc.k)
            reverse_proc = Process(proc.products, proc.reactants, proc.k_rev)
            procs.remove(proc)
            procs.extend([forward_proc, reverse_proc])

    assert len(set(procs)) == len(procs), \
        &#34;WARNING: Duplicate processes found. Examine the list of processes to resolve this.&#34;

    all_species, rspecies, pspecies = set(), set(), set()
    procs_by_reactant, procs_by_product = dict(), dict()

    for proc in procs:
        all_species = all_species.union(proc.species)
        rspecies = rspecies.union(proc.reactants)
        pspecies = pspecies.union(proc.products)

    # Make a list containing the processes each reactant species takes part in.
    # This will be used when solving the system ODEs.
    for rspec in rspecies:
        if rspec != &#39;&#39;:  # omit reactant species parsed from 0th order processes
            procs_by_reactant[rspec] = [proc for proc in procs if rspec in proc.reactants]
            # deleted 1st clause in above `if`: `rspec != &#39;&#39; and`

    # Make a list containing the processes each product species takes part in.
    # This will be used for solving the system ODEs.
    for pspec in pspecies:
        if pspec != &#39;&#39;:  # omitting product species parsed from degradation processes
            procs_by_product[pspec] = [proc for proc in procs if pspec in proc.products]

    return all_species, procs_by_reactant, procs_by_product</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="abstochkin.process.update_all_species"><code class="name flex">
<span>def <span class="ident">update_all_species</span></span>(<span>procs:tuple[<a title="abstochkin.process.Process" href="#abstochkin.process.Process">Process</a>,...]) >tuple[set,dict,dict]</span>
</code></dt>
<dd>
<div class="desc"><p>Categorize all species in a list of processes.</p>
<p>Extract all species from a list of processes. Then categorize each of them
as a reactant or product and list the process(es) it takes part in.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>procs</code></strong> :&ensp;<code>tuple</code></dt>
<dd>A tuple of objects of type <code><a title="abstochkin.process.Process" href="#abstochkin.process.Process">Process</a></code> or its subclasses.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>all_species : set of strings
A set of all species present in the processes.
procs_by_reactant : dict
A dictionary whose keys are the species that are
reactants in one or more processes. The value for each
key is a list of processes.
procs_by_product : dict
A dictionary whose keys are the species that are
products in one or more processes. The value for each
key is a list of processes.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_all_species(procs: tuple[Process, ...]) -&gt; tuple[set, dict, dict]:
    &#34;&#34;&#34; Categorize all species in a list of processes.

    Extract all species from a list of processes. Then categorize each of them
    as a reactant or product and list the process(es) it takes part in.

    Parameters
    ----------
    procs : tuple
        A tuple of objects of type `Process` or its subclasses.

    Returns
    -------
    tuple
        all_species : set of strings
            A set of all species present in the processes.
        procs_by_reactant : dict
            A dictionary whose keys are the species that are
            reactants in one or more processes. The value for each
            key is a list of processes.
        procs_by_product : dict
            A dictionary whose keys are the species that are
            products in one or more processes. The value for each
            key is a list of processes.
    &#34;&#34;&#34;
    procs = list(procs)
    for proc in procs:
        # For a reversible process, replace it with separate instances
        # of Process objects representing the forward and reverse reactions.
        if isinstance(proc, ReversibleProcess):
            forward_proc = Process(proc.reactants, proc.products, proc.k)
            reverse_proc = Process(proc.products, proc.reactants, proc.k_rev)
            procs.remove(proc)
            procs.extend([forward_proc, reverse_proc])

    assert len(set(procs)) == len(procs), \
        &#34;WARNING: Duplicate processes found. Examine the list of processes to resolve this.&#34;

    all_species, rspecies, pspecies = set(), set(), set()
    procs_by_reactant, procs_by_product = dict(), dict()

    for proc in procs:
        all_species = all_species.union(proc.species)
        rspecies = rspecies.union(proc.reactants)
        pspecies = pspecies.union(proc.products)

    # Make a list containing the processes each reactant species takes part in.
    # This will be used when solving the system ODEs.
    for rspec in rspecies:
        if rspec != &#39;&#39;:  # omit reactant species parsed from 0th order processes
            procs_by_reactant[rspec] = [proc for proc in procs if rspec in proc.reactants]
            # deleted 1st clause in above `if`: `rspec != &#39;&#39; and`

    # Make a list containing the processes each product species takes part in.
    # This will be used for solving the system ODEs.
    for pspec in pspecies:
        if pspec != &#39;&#39;:  # omitting product species parsed from degradation processes
            procs_by_product[pspec] = [proc for proc in procs if pspec in proc.products]

    return all_species, procs_by_reactant, procs_by_product</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="abstochkin.process.MichaelisMentenProcess"><code class="flex name class">
<span>class <span class="ident">MichaelisMentenProcess</span></span>
<span>(</span><span>reactants:dict, products:dict, k:float|int|list[float|int,...]|tuple[float|int,float|int], catalyst:str, Km:float|int|list[float|int,...]|tuple[float|int,float|int])</span>
</code></dt>
<dd>
<div class="desc"><p>Define a process that obeys Michaelis-Menten kinetics.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>catalyst</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the species acting as a catalyst for this process.</dd>
<dt><strong><code>Km</code></strong> :&ensp;<code>float</code> or <code>int</code> or <code>list</code> of <code>floats</code> or <code>2-tuple</code> of <code>floats</code></dt>
<dd><em>Microscopic</em> Michaelis constant. Corresponds to the number
of <code>catalyst</code> agents that would produce half-maximal activity.
Heterogeneity in this parameter is determined by the type of <code>K50</code>,
using the same rules as for parameter <code>k</code>.</dd>
<dt><strong><code>is_heterogeneous_Km</code></strong> :&ensp;<code>bool</code></dt>
<dd>Denotes if the parameter <code>Km</code> exhibits heterogeneity
(distinct subspecies/interactions or normally-distributed).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MichaelisMentenProcess(Process):
    &#34;&#34;&#34; Define a process that obeys Michaelis-Menten kinetics.

    Attributes
    ----------
    catalyst : str
        Name of the species acting as a catalyst for this process.
    Km : float or int or list of floats or 2-tuple of floats
        *Microscopic* Michaelis constant. Corresponds to the number
        of `catalyst` agents that would produce half-maximal activity.
        Heterogeneity in this parameter is determined by the type of `K50`,
        using the same rules as for parameter `k`.
    is_heterogeneous_Km : bool
        Denotes if the parameter `Km` exhibits heterogeneity
        (distinct subspecies/interactions or normally-distributed).
    &#34;&#34;&#34;

    def __init__(self, reactants: dict, products: dict,
                 k: float | int | list[float | int, ...] | tuple[float | int, float | int],
                 catalyst: str,
                 Km: float | int | list[float | int, ...] | tuple[float | int, float | int]):
        self.catalyst = catalyst
        self.Km = Km
        self.is_heterogeneous_Km = False if isinstance(self.Km, (int, float)) else True

        super().__init__(reactants, products, k)

        self.species.add(self.catalyst)
        self._str += f&#34;, catalyst = {self.catalyst}, Km = {self.Km}&#34;

        assert self.order != 0, &#34;A 0th order process has no substrate for a catalyst &#34; \
                                &#34;to act on, therefore it cannot follow Michaelis-Menten kinetics.&#34;
        if self.order == 2:
            raise NotImplementedError

    @classmethod
    def from_string(cls,
                    proc_str: str,
                    /,
                    k: float | int | list[float | int, ...] | tuple[float | int, float | int],
                    *,
                    catalyst: str = None,
                    Km: float | int | list[float | int, ...] | tuple[
                        float | int, float | int] = None,
                    sep: str = &#39;-&gt;&#39;) -&gt; Self:
        &#34;&#34;&#34; Create a Michaelis-Menten process from a string.

        Parameters
        ----------
        proc_str : str
            A string describing the process in standard chemical notation
            (e.g., &#39;A + B -&gt; C&#39;)
        k : float or int or list of floats or 2-tuple of floats
            The *microscopic* rate constant for the given process. If `k` is a
            float or int, then the process is homogeneous. If `k` is a list, then
            the population of the reactants constsists of distinct subspecies
            or subinteractions depending on the order. If `k` is a 2-tuple,
            then the constant is normally-distributed with a mean and standard
            deviation specified in the tuple&#39;s elements.
        catalyst : str
            Name of species acting as a catalyst.
        Km : float or int or list of floats or 2-tuple of floats
            *Microscopic* Michaelis constant for the process.
            Heterogeneity in this parameter is determined by the type of `Km`,
            using the same rules as for parameter `k`.
        sep : str, default: &#39;-&gt;&#39;
            Specifies the characters that distinguish the reactants from the
            products. The default is &#39;-&gt;&#39;. The code also treats `--&gt;` as a
            default, if it&#39;s present in `proc_str`.

        Notes
        -----
        - Species names should not contain spaces, dashes, and
          should start with a non-numeric character.
        - Zeroth order processes should be specified by an empty space or &#39;None&#39;.

        Examples
        --------
        &gt;&gt;&gt; MichaelisMentenProcess.from_string(&#34;A -&gt; X&#34;, k=0.3, catalyst=&#39;E&#39;, Km=10)
        &gt;&gt;&gt; MichaelisMentenProcess.from_string(&#34;A -&gt; X&#34;, k=0.3, catalyst=&#39;alpha&#39;, Km=(10, 1))
        &#34;&#34;&#34;
        sep = &#39;--&gt;&#39; if &#39;--&gt;&#39; in proc_str else sep
        if sep not in proc_str:
            raise Exception(&#34;Cannot distinguish the reactants from the products.\n&#34;
                            &#34;Please use the *sep* keyword: e.g. sep=&#39;-&gt;&#39;.&#34;)

        lhs, rhs = proc_str.strip().split(sep)  # Left- and Right-hand sides of process
        lhs_terms = lhs.split(&#39;+&#39;)  # Separate the terms on the left-hand side
        rhs_terms = rhs.split(&#39;+&#39;)  # Separate the terms on the right-hand side

        return cls(cls._to_dict(lhs_terms), cls._to_dict(rhs_terms),
                   k,
                   catalyst, Km)

    def __str__(self):
        if isinstance(self.Km, (float, int)):
            Km_het_str = &#34;Homogeneous process with respect to Km.&#34;
        elif isinstance(self.k, list):
            Km_het_str = f&#34;Heterogeneous process with respect to Km &#34; \
                         f&#34;with {len(self.Km)} distinct subspecies.&#34;
        else:
            Km_het_str = f&#34;Heterogeneous process with normally-distributed Km with &#34; \
                         f&#34;mean {self.Km[0]} and standard deviation {self.Km[1]}.&#34;

        return super().__str__() + f&#34; Catalyst: {self.catalyst}, &#34; \
                                   f&#34;Km = {self.Km}, {Km_het_str}&#34;

    def __repr__(self):
        return f&#34;MichaelisMentenProcess Object: &#34; \
               f&#34;MichaelisMentenProcess.from_string(&#39;{self._str.split(&#39;,&#39;)[0]}&#39;, &#34; \
               f&#34;k={self.k}, &#34; \
               f&#34;catalyst=&#39;{self.catalyst}&#39;, &#34; \
               f&#34;Km={self.Km})&#34;

    def __eq__(self, other):
        if isinstance(other, MichaelisMentenProcess):
            is_equal = (self.k == other.k and
                        self.order == other.order and
                        self.reactants == other.reactants and
                        self.products == other.products and
                        self.catalyst == other.catalyst and
                        self.Km == other.Km and
                        self.species == other.species)
            return is_equal
        elif isinstance(other, str):
            return self._str == other or self._str.replace(&#39; &#39;, &#39;&#39;) == other
        else:
            print(f&#34;{type(self)} and {type(other)} are instances of different classes.&#34;)
            return False

    def __hash__(self):
        return hash(self._str)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="abstochkin.process.Process" href="#abstochkin.process.Process">Process</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="abstochkin.process.MichaelisMentenProcess.from_string"><code class="name flex">
<span>def <span class="ident">from_string</span></span>(<span>proc_str:str, /, k:float|int|list[float|int,...]|tuple[float|int,float|int], *, catalyst:str=None, Km:float|int|list[float|int,...]|tuple[float|int,float|int]=None, sep:str=&#x27;-&gt;&#x27;) >Self</span>
</code></dt>
<dd>
<div class="desc"><p>Create a Michaelis-Menten process from a string.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>proc_str</code></strong> :&ensp;<code>str</code></dt>
<dd>A string describing the process in standard chemical notation
(e.g., 'A + B -&gt; C')</dd>
<dt><strong><code>k</code></strong> :&ensp;<code>float</code> or <code>int</code> or <code>list</code> of <code>floats</code> or <code>2-tuple</code> of <code>floats</code></dt>
<dd>The <em>microscopic</em> rate constant for the given process. If <code>k</code> is a
float or int, then the process is homogeneous. If <code>k</code> is a list, then
the population of the reactants constsists of distinct subspecies
or subinteractions depending on the order. If <code>k</code> is a 2-tuple,
then the constant is normally-distributed with a mean and standard
deviation specified in the tuple's elements.</dd>
<dt><strong><code>catalyst</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of species acting as a catalyst.</dd>
<dt><strong><code>Km</code></strong> :&ensp;<code>float</code> or <code>int</code> or <code>list</code> of <code>floats</code> or <code>2-tuple</code> of <code>floats</code></dt>
<dd><em>Microscopic</em> Michaelis constant for the process.
Heterogeneity in this parameter is determined by the type of <code>Km</code>,
using the same rules as for parameter <code>k</code>.</dd>
<dt><strong><code>sep</code></strong> :&ensp;<code>str</code>, default<code>: '-&gt;'</code></dt>
<dd>Specifies the characters that distinguish the reactants from the
products. The default is '-&gt;'. The code also treats <code>--&gt;</code> as a
default, if it's present in <code>proc_str</code>.</dd>
</dl>
<h2 id="notes">Notes</h2>
<ul>
<li>Species names should not contain spaces, dashes, and
should start with a non-numeric character.</li>
<li>Zeroth order processes should be specified by an empty space or 'None'.</li>
</ul>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; MichaelisMentenProcess.from_string(&quot;A -&gt; X&quot;, k=0.3, catalyst='E', Km=10)
&gt;&gt;&gt; MichaelisMentenProcess.from_string(&quot;A -&gt; X&quot;, k=0.3, catalyst='alpha', Km=(10, 1))
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_string(cls,
                proc_str: str,
                /,
                k: float | int | list[float | int, ...] | tuple[float | int, float | int],
                *,
                catalyst: str = None,
                Km: float | int | list[float | int, ...] | tuple[
                    float | int, float | int] = None,
                sep: str = &#39;-&gt;&#39;) -&gt; Self:
    &#34;&#34;&#34; Create a Michaelis-Menten process from a string.

    Parameters
    ----------
    proc_str : str
        A string describing the process in standard chemical notation
        (e.g., &#39;A + B -&gt; C&#39;)
    k : float or int or list of floats or 2-tuple of floats
        The *microscopic* rate constant for the given process. If `k` is a
        float or int, then the process is homogeneous. If `k` is a list, then
        the population of the reactants constsists of distinct subspecies
        or subinteractions depending on the order. If `k` is a 2-tuple,
        then the constant is normally-distributed with a mean and standard
        deviation specified in the tuple&#39;s elements.
    catalyst : str
        Name of species acting as a catalyst.
    Km : float or int or list of floats or 2-tuple of floats
        *Microscopic* Michaelis constant for the process.
        Heterogeneity in this parameter is determined by the type of `Km`,
        using the same rules as for parameter `k`.
    sep : str, default: &#39;-&gt;&#39;
        Specifies the characters that distinguish the reactants from the
        products. The default is &#39;-&gt;&#39;. The code also treats `--&gt;` as a
        default, if it&#39;s present in `proc_str`.

    Notes
    -----
    - Species names should not contain spaces, dashes, and
      should start with a non-numeric character.
    - Zeroth order processes should be specified by an empty space or &#39;None&#39;.

    Examples
    --------
    &gt;&gt;&gt; MichaelisMentenProcess.from_string(&#34;A -&gt; X&#34;, k=0.3, catalyst=&#39;E&#39;, Km=10)
    &gt;&gt;&gt; MichaelisMentenProcess.from_string(&#34;A -&gt; X&#34;, k=0.3, catalyst=&#39;alpha&#39;, Km=(10, 1))
    &#34;&#34;&#34;
    sep = &#39;--&gt;&#39; if &#39;--&gt;&#39; in proc_str else sep
    if sep not in proc_str:
        raise Exception(&#34;Cannot distinguish the reactants from the products.\n&#34;
                        &#34;Please use the *sep* keyword: e.g. sep=&#39;-&gt;&#39;.&#34;)

    lhs, rhs = proc_str.strip().split(sep)  # Left- and Right-hand sides of process
    lhs_terms = lhs.split(&#39;+&#39;)  # Separate the terms on the left-hand side
    rhs_terms = rhs.split(&#39;+&#39;)  # Separate the terms on the right-hand side

    return cls(cls._to_dict(lhs_terms), cls._to_dict(rhs_terms),
               k,
               catalyst, Km)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="abstochkin.process.NullSpeciesNameError"><code class="flex name class">
<span>class <span class="ident">NullSpeciesNameError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Error when the species name is an empty string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NullSpeciesNameError(Exception):
    &#34;&#34;&#34; Error when the species name is an empty string. &#34;&#34;&#34;

    def __str__(self):
        return &#34;A species name cannot be an empty string.&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="abstochkin.process.Process"><code class="flex name class">
<span>class <span class="ident">Process</span></span>
<span>(</span><span>reactants:dict, products:dict, k:float|int|list[float,...]|tuple[float,float], **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Define a unidirectional process: Reactants -&gt; Products, where the
Reactants and Products are specified using standard chemical notation.
That is, stoichiometric coefficients (integers) and species names are
specified. For example: 2A + B -&gt; C.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>reactants</code></strong> :&ensp;<code>dict</code></dt>
<dd>The reactants of a given process are specified with
key-value pairs describing each species name and its
stoichiometric coefficient, respectively.</dd>
<dt><strong><code>products</code></strong> :&ensp;<code>dict</code></dt>
<dd>The products of a given process are specified with
key-value pairs describing each species name and its
stoichiometric coefficient, respectively.</dd>
<dt><strong><code>k</code></strong> :&ensp;<code>float, int, list</code> of <code>floats, tuple</code> of <code>floats</code></dt>
<dd>The <em>microscopic</em> rate constant(s) for the given process. The data
type of <code>k</code> determines the "structure" of the population as follows:
- A homogeneous population: if <code>k</code> is a single value (float or int),
then the population is assumed to be homogeneous with all agents
of the reactant species having kinetics defined by this value.
- A heterogeneous population with a distinct number of subspecies
(each with a corresponding <code>k</code> value): if <code>k</code> is a list of floats,
then the population is assumed to be heterogeneous with a number
of subspecies equal to the length of the list.
- A heterogeneous population with normally-distributed <code>k</code> values:
If <code>k</code> is a tuple whose length is 2, then the population is
assumed to be heterogeneous with a normally distributed <code>k</code> value.
The two entries in the tuple represent the mean and standard
deviation (in that order) of the desired normal distribution.</dd>
<dt><strong><code>order</code></strong> :&ensp;<code>int</code></dt>
<dd>The order of the process (or the molecularity of an elementary process).
It is the sum of the stoichiometric coefficients of the reactants.</dd>
<dt><strong><code>species</code></strong> :&ensp;<code>set</code> of <code>strings</code></dt>
<dd>A set of all species in a process.</dd>
<dt><strong><code>reacts_</code></strong> :&ensp;<code>list</code> of <code>strings</code></dt>
<dd>A list containing all the reactants in a process.</dd>
<dt><strong><code>prods_</code></strong> :&ensp;<code>list</code> of <code>strings</code></dt>
<dd>A list containing all the products in a process.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>from_string
Class method for creating a Process object from a string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Process:
    &#34;&#34;&#34;
    Define a unidirectional process: Reactants -&gt; Products, where the
    Reactants and Products are specified using standard chemical notation.
    That is, stoichiometric coefficients (integers) and species names are
    specified. For example: 2A + B -&gt; C.

    Attributes
    ----------
    reactants : dict
        The reactants of a given process are specified with
        key-value pairs describing each species name and its
        stoichiometric coefficient, respectively.
    products : dict
        The products of a given process are specified with
        key-value pairs describing each species name and its
        stoichiometric coefficient, respectively.
    k : float, int, list of floats, tuple of floats
        The *microscopic* rate constant(s) for the given process. The data
        type of `k` determines the &#34;structure&#34; of the population as follows:
            - A homogeneous population: if `k` is a single value (float or int),
              then the population is assumed to be homogeneous with all agents
              of the reactant species having kinetics defined by this value.
            - A heterogeneous population with a distinct number of subspecies
              (each with a corresponding `k` value): if `k` is a list of floats,
              then the population is assumed to be heterogeneous with a number
              of subspecies equal to the length of the list.
            - A heterogeneous population with normally-distributed `k` values:
              If `k` is a tuple whose length is 2, then the population is
              assumed to be heterogeneous with a normally distributed `k` value.
              The two entries in the tuple represent the mean and standard
              deviation (in that order) of the desired normal distribution.
    order : int
        The order of the process (or the molecularity of an elementary process).
        It is the sum of the stoichiometric coefficients of the reactants.
    species : set of strings
        A set of all species in a process.
    reacts_ : list of strings
        A list containing all the reactants in a process.
    prods_ : list of strings
        A list containing all the products in a process.

    Methods
    -------
    from_string
        Class method for creating a Process object from a string.
    &#34;&#34;&#34;

    def __init__(self,
                 reactants: dict,
                 products: dict,
                 k: float | int | list[float, ...] | tuple[float, float],
                 **kwargs):

        self.reactants = reactants
        self.products = products
        self.k = k

        self._validate_nums()  # make sure there are no errors in given numbers

        # For consistency with processes instantiated using the class method `from_string()`,
        # species denoted as &#39;None&#39; for a 0th order process are renamed to &#39;&#39;.
        if &#39;None&#39; in self.reactants.keys():
            self.reactants[&#39;&#39;] = self.reactants.pop(&#39;None&#39;)
        if &#39;None&#39; in self.products.keys():
            self.products[&#39;&#39;] = self.products.pop(&#39;None&#39;)

        self.order = sum(self.reactants.values())

        self.is_heterogeneous = False if isinstance(self.k, (int, float)) else True

        if self.order == 0:
            msg = &#34;Since a birth process does not depended on the presence of agents, &#34; \
                  &#34;heterogeneity does not make sense in this context. Please define &#34; \
                  &#34;the rate constant k as a number. &#34;
            assert not self.is_heterogeneous, msg

        # Two ways of storing the involved species:
        # 1) A set of all species
        self.species = set((self.reactants | self.products).keys())
        with contextlib.suppress(KeyError):
            self.species.remove(&#39;&#39;)  # remove empty species name from any 0th order processes

        # 2) Separate lists
        self.reacts_ = list()  # [reactant species]
        self.prods_ = list()  # [product species]
        self._get_reacts_prods_()

        &#34;&#34;&#34; Because Process objects are used as keys in dictionaries used 
        in an AbStochKin simulation, it&#39;s much faster to generate the object&#39;s 
        string representation once, and then access it whenever it&#39;s needed 
        (which could be thousands of times during a simulation). &#34;&#34;&#34;
        self._str = self.__str__().split(&#39;;&#39;)[0]

        if len(kwargs) &gt; 0:
            self._lsp(kwargs)

    def _get_reacts_prods_(self):
        &#34;&#34;&#34; Make lists of the reactant and product species. Repeated
        elements of a list reflect the order or molecularity of the
        species in the given process. For example, for the process
        `2A + B -&gt; C + D, reacts_ = [&#39;A&#39;, &#39;A&#39;, &#39;B&#39;], prods_ = [&#39;C&#39;, &#39;D&#39;]`. &#34;&#34;&#34;
        for r, m in self.reactants.items():
            for i in range(m):
                self.reacts_.append(r)

        for p, m in self.products.items():
            for i in range(m):
                self.prods_.append(p)

        if &#39;&#39; in self.reacts_:  # remove empty reactant species names
            self.reacts_.remove(&#39;&#39;)  # from 0th order processes
        if &#39;&#39; in self.prods_:  # remove empty product species names
            self.prods_.remove(&#39;&#39;)  # from degradation processes

    @classmethod
    def from_string(cls,
                    proc_str: str,
                    /,
                    k: float | int | list[float, ...] | tuple[float, float],
                    *,
                    sep: str = &#39;-&gt;&#39;,
                    **kwargs) -&gt; Self:
        &#34;&#34;&#34; Create a process from a string.

        Parameters
        ----------
        proc_str : str
            A string describing the process in standard chemical notation
            (e.g., &#39;A + B -&gt; C&#39;)
        k : float or int or list of floats or 2-tuple of floats
            The rate constant for the given process. If `k` is a float or
            int, then the process is homogeneous. If `k` is a list, then
            the population of the reactants constsists of distinct subspecies
            or subinteractions depending on the order. If `k` is a 2-tuple,
            then the constant is normally-distributed with a mean and standard
            deviation specified in the tuple&#39;s elements.
        sep : str, default: &#39;-&gt;&#39;
            Specifies the characters that distinguish the reactants from the
            products. The default is &#39;-&gt;&#39;. The code also treats `--&gt;` as a
            default, if it&#39;s present in `proc_str`.

        Notes
        -----
        - Species names should not contain spaces, dashes, and
          should start with a non-numeric character.
        - Zeroth order processes should be specified by an empty space or &#39;None&#39;.

        Examples
        --------
        &gt;&gt;&gt; Process.from_string(&#34;2A + B -&gt; X&#34;, 0.3)
        &gt;&gt;&gt; Process.from_string(&#34; -&gt; Y&#34;, 0.1)  # for a 0th order (birth) process.
        &gt;&gt;&gt; Process.from_string(&#34;Protein_X -&gt; None&#34;, 0.15)  # for a 1st order degradation process.
        &#34;&#34;&#34;

        if len(kwargs) &gt; 0:
            cls._lsp(kwargs)

        sep = &#39;--&gt;&#39; if &#39;--&gt;&#39; in proc_str else sep
        if sep not in proc_str:
            raise Exception(&#34;Cannot distinguish the reactants from the products.\n&#34;
                            &#34;Please use the *sep* keyword: e.g. sep=&#39;-&gt;&#39;.&#34;)

        lhs, rhs = proc_str.strip().split(sep)  # Left- and Right-hand sides of process
        lhs_terms = lhs.split(&#39;+&#39;)  # Separate the terms on the left-hand side
        rhs_terms = rhs.split(&#39;+&#39;)  # Separate the terms on the right-hand side

        return cls(cls._to_dict(lhs_terms), cls._to_dict(rhs_terms), k)

    @staticmethod
    def _lsp(kwargs: dict):
        &#34;&#34;&#34;
        The `Process` class accepts additional arguments (`**kwargs`).
        Since the Process class is a base class for other subclasses,
        this is done so that the Liskov Substitution Principle (LSP)
        is not violated.
        (https://en.wikipedia.org/wiki/Liskov_substitution_principle).
        This way, subclasses override the `from_string` method and have
        additional parameters while remaining consistent with this method
        from their base class. Calling the base instance with the additional
        parameters gives a warning that they will have no effect so that
        the user can intervene, if that&#39;s desired.
        &#34;&#34;&#34;
        msg = f&#34;Warning: Additional parameters {&#39;,&#39;.join([str(i) for i in kwargs.items()])} &#34; \
              f&#34;will have no effect. &#34;
        if &#39;k_rev&#39; in kwargs.keys():
            msg += f&#34;If that&#39;s not what you intended, define the process &#34; \
                   f&#34;using ReversibleProcess().&#34;
        if &#39;regulating_species&#39; in kwargs.keys() or &#39;alpha&#39; in kwargs.keys() or \
                &#39;nH&#39; in kwargs.keys() or &#39;K50&#39; in kwargs.keys():
            msg += f&#34;If that&#39;s not what you intended, define the process &#34; \
                   f&#34;using RegulatedProcess().&#34;
        if &#39;catalyst&#39; in kwargs.keys():
            msg += f&#34;If that&#39;s not what you intended, define the process &#34; \
                   f&#34;using MichaelisMentenProcess().&#34;
        print(msg)

    @staticmethod
    def _to_dict(terms: list) -&gt; dict:
        &#34;&#34;&#34; Convert the information for a side of a process to a dictionary. &#34;&#34;&#34;

        side_terms = dict()  # for storing the information of a side of a process
        patt = &#39;^[\\-]*[1-9]+&#39;  # regex pattern (accounts for leading erroneous minus sign)

        if len(terms) == 1 and terms[0].strip().lower() in [&#39;&#39;, &#39;none&#39;]:
            spec = &#39;&#39;  # Zeroth order process
            side_terms[spec] = 0
        else:
            for term in terms:
                term = term.strip()
                try:
                    match = re.search(patt, term)
                    stoic_coef = term[slice(*match.span())]  # extract stoichiometric coef
                    spec = re.split(patt, term)[-1].strip()  # extract species name
                    if spec == &#39;&#39; and stoic_coef != 0:
                        raise NullSpeciesNameError()
                    stoic_coef = int(stoic_coef)
                except AttributeError:  # when there is no specified stoichiometric coefficient
                    spec = re.split(patt, term)[-1]  # extract species name
                    stoic_coef = 1

                if spec not in side_terms.keys():
                    side_terms[spec] = stoic_coef
                else:
                    side_terms[spec] += stoic_coef

        return side_terms

    def _validate_nums(self):
        &#34;&#34;&#34; Make sure coefficients and rate constant values are not negative. &#34;&#34;&#34;
        for r, val in (self.reactants | self.products).items():
            assert val &gt;= 0, f&#34;Coefficient cannot be negative: {val} {r}.&#34;

        error_msg = f&#34;Rate constant values have to be positive: k = {self.k}.&#34;
        if isinstance(self.k, (list, tuple)):  # heterogeneous population
            assert all(array(self.k) &gt; 0), error_msg
        else:  # when k is a float or int, the population is homogeneous
            assert self.k &gt; 0, error_msg

        # For normally-distributed k values, specification is a 2-tuple.
        if isinstance(self.k, tuple):  # normal distribution of k values
            assert len(self.k) == 2, &#34;Please specify the mean and standard deviation &#34; \
                                     &#34;of k in a 2-tuple: (mean, std).&#34;

    def __eq__(self, other):
        if isinstance(other, Process):
            is_equal = (self.k == other.k and
                        self.order == other.order and
                        self.reactants == other.reactants and
                        self.products == other.products and
                        self.species == other.species)
            return is_equal
        elif isinstance(other, str):
            return self._str == other or self._str.replace(&#39; &#39;, &#39;&#39;) == other
        else:
            print(f&#34;{type(self)} and {type(other)} are instances of different classes.&#34;)
            return False

    def __hash__(self):
        return hash(self._str)

    def __contains__(self, item):
        return True if item in self.species else False

    def __repr__(self):
        return f&#34;Process Object: Process.from_string(&#39;{self._str.split(&#39;,&#39;)[0]}&#39;, k={self.k})&#34;

    def __str__(self):
        if isinstance(self.k, (float, int)):
            het_str = &#34;Homogeneous process.&#34;
        elif isinstance(self.k, list):
            het_str = f&#34;Heterogeneous process with {len(self.k)} distinct subspecies.&#34;
        else:
            het_str = f&#34;Heterogeneous process with normally-distributed k with &#34; \
                      f&#34;mean {self.k[0]} and standard deviation {self.k[1]}.&#34;

        lhs, rhs = self._reconstruct_string()
        return &#39; -&gt; &#39;.join([lhs, rhs]) + f&#39;, k = {self.k}; {het_str}&#39;

    def _reconstruct_string(self):
        lhs = &#39; + &#39;.join([f&#34;{str(val) + &#39; &#39; if val not in [0, 1] else &#39;&#39;}{key}&#34; for key, val in
                          self.reactants.items()])
        rhs = &#39; + &#39;.join([f&#34;{str(val) + &#39; &#39; if val not in [0, 1] else &#39;&#39;}{key}&#34; for key, val in
                          self.products.items()])
        return lhs, rhs</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="abstochkin.process.MichaelisMentenProcess" href="#abstochkin.process.MichaelisMentenProcess">MichaelisMentenProcess</a></li>
<li><a title="abstochkin.process.RegulatedProcess" href="#abstochkin.process.RegulatedProcess">RegulatedProcess</a></li>
<li><a title="abstochkin.process.ReversibleProcess" href="#abstochkin.process.ReversibleProcess">ReversibleProcess</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="abstochkin.process.Process.from_string"><code class="name flex">
<span>def <span class="ident">from_string</span></span>(<span>proc_str:str, /, k:float|int|list[float,...]|tuple[float,float], *, sep:str=&#x27;-&gt;&#x27;, **kwargs) >Self</span>
</code></dt>
<dd>
<div class="desc"><p>Create a process from a string.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>proc_str</code></strong> :&ensp;<code>str</code></dt>
<dd>A string describing the process in standard chemical notation
(e.g., 'A + B -&gt; C')</dd>
<dt><strong><code>k</code></strong> :&ensp;<code>float</code> or <code>int</code> or <code>list</code> of <code>floats</code> or <code>2-tuple</code> of <code>floats</code></dt>
<dd>The rate constant for the given process. If <code>k</code> is a float or
int, then the process is homogeneous. If <code>k</code> is a list, then
the population of the reactants constsists of distinct subspecies
or subinteractions depending on the order. If <code>k</code> is a 2-tuple,
then the constant is normally-distributed with a mean and standard
deviation specified in the tuple's elements.</dd>
<dt><strong><code>sep</code></strong> :&ensp;<code>str</code>, default<code>: '-&gt;'</code></dt>
<dd>Specifies the characters that distinguish the reactants from the
products. The default is '-&gt;'. The code also treats <code>--&gt;</code> as a
default, if it's present in <code>proc_str</code>.</dd>
</dl>
<h2 id="notes">Notes</h2>
<ul>
<li>Species names should not contain spaces, dashes, and
should start with a non-numeric character.</li>
<li>Zeroth order processes should be specified by an empty space or 'None'.</li>
</ul>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; Process.from_string(&quot;2A + B -&gt; X&quot;, 0.3)
&gt;&gt;&gt; Process.from_string(&quot; -&gt; Y&quot;, 0.1)  # for a 0th order (birth) process.
&gt;&gt;&gt; Process.from_string(&quot;Protein_X -&gt; None&quot;, 0.15)  # for a 1st order degradation process.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_string(cls,
                proc_str: str,
                /,
                k: float | int | list[float, ...] | tuple[float, float],
                *,
                sep: str = &#39;-&gt;&#39;,
                **kwargs) -&gt; Self:
    &#34;&#34;&#34; Create a process from a string.

    Parameters
    ----------
    proc_str : str
        A string describing the process in standard chemical notation
        (e.g., &#39;A + B -&gt; C&#39;)
    k : float or int or list of floats or 2-tuple of floats
        The rate constant for the given process. If `k` is a float or
        int, then the process is homogeneous. If `k` is a list, then
        the population of the reactants constsists of distinct subspecies
        or subinteractions depending on the order. If `k` is a 2-tuple,
        then the constant is normally-distributed with a mean and standard
        deviation specified in the tuple&#39;s elements.
    sep : str, default: &#39;-&gt;&#39;
        Specifies the characters that distinguish the reactants from the
        products. The default is &#39;-&gt;&#39;. The code also treats `--&gt;` as a
        default, if it&#39;s present in `proc_str`.

    Notes
    -----
    - Species names should not contain spaces, dashes, and
      should start with a non-numeric character.
    - Zeroth order processes should be specified by an empty space or &#39;None&#39;.

    Examples
    --------
    &gt;&gt;&gt; Process.from_string(&#34;2A + B -&gt; X&#34;, 0.3)
    &gt;&gt;&gt; Process.from_string(&#34; -&gt; Y&#34;, 0.1)  # for a 0th order (birth) process.
    &gt;&gt;&gt; Process.from_string(&#34;Protein_X -&gt; None&#34;, 0.15)  # for a 1st order degradation process.
    &#34;&#34;&#34;

    if len(kwargs) &gt; 0:
        cls._lsp(kwargs)

    sep = &#39;--&gt;&#39; if &#39;--&gt;&#39; in proc_str else sep
    if sep not in proc_str:
        raise Exception(&#34;Cannot distinguish the reactants from the products.\n&#34;
                        &#34;Please use the *sep* keyword: e.g. sep=&#39;-&gt;&#39;.&#34;)

    lhs, rhs = proc_str.strip().split(sep)  # Left- and Right-hand sides of process
    lhs_terms = lhs.split(&#39;+&#39;)  # Separate the terms on the left-hand side
    rhs_terms = rhs.split(&#39;+&#39;)  # Separate the terms on the right-hand side

    return cls(cls._to_dict(lhs_terms), cls._to_dict(rhs_terms), k)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="abstochkin.process.RegulatedMichaelisMentenProcess"><code class="flex name class">
<span>class <span class="ident">RegulatedMichaelisMentenProcess</span></span>
<span>(</span><span>reactants:dict, products:dict, k:float|int|list[float,...]|tuple[float,float], regulating_species:str|list[str,...], alpha:float|int|list[float|int,...], K50:float|int|list[float|int,...]|tuple[float|int,float|int]|list[float|int|list[float|int,...]|tuple[float|int,float|int]], nH:float|int|list[float|int,...], catalyst:str, Km:float|int|list[float|int,...]|tuple[float|int,float|int])</span>
</code></dt>
<dd>
<div class="desc"><p>Define a process that is regulated and obeys Michaelis-Menten kinetics.</p>
<p>This class allows a Michaelis-Menten Process to be defined
in terms of how it is regulated.
If there is only one regulating species, then the parameters have the same
type as would be expected for a homogeneous/heterogeneous process.
If there are multiple regulating species, then all parameters are a list
of their expected type, with the length of the list being equal to the
number of regulating species.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>k</code></strong> :&ensp;<code>float</code> or <code>int</code> or <code>list</code> of <code>floats</code> or <code>2-tuple</code> of <code>floats</code></dt>
<dd>The <em>microscopic</em> rate constant for the given process. It is the <em>basal</em>
rate constant in the case of activation (or the minimum <code>k</code> value)
and the maximum rate constant in the case of repression.</dd>
<dt><strong><code>regulating_species</code></strong> :&ensp;<code>str</code> or <code>list</code> of <code>str</code></dt>
<dd>Name of the regulating species. Multiple species can be specified as
comma-separated in a string or a list of strings with the species names.</dd>
<dt><strong><code>alpha</code></strong> :&ensp;<code>float</code> or <code>int</code> or <code>list[float</code> or <code>int]</code></dt>
<dd>
<p>Parameter denoting the degree of activation/repression.</p>
<pre><code>- 0 &lt;= alpha &lt; 1: repression
- alpha = 1: no regulation
- alpha &gt; 1: activation
</code></pre>
<p>alpha is a multiplier: in the case of activation, the maximum
rate constant value will be <code>alpha * k</code>.
In the case of repression, the minimum
rate constant value will be <code>alpha * k</code>.</p>
</dd>
<dt><strong><code>K50</code></strong> :&ensp;<code>float</code> or <code>int</code> or <code>list</code> of <code>floats</code> or <code>2-tuple</code> of <code>floats</code> or <code>list[float</code> or <code>int</code> or <code>list</code> of <code>floats</code> or <code>2-tuple</code> of <code>floats]</code></dt>
<dd><em>Microscopic</em> constant that corresponds to the number of
<code>regulating_species</code> agents that would produce
half-maximal activation/repression.
Heterogeneity in this parameter is determined by the type of <code>K50</code>,
using the same rules as for parameter <code>k</code>.</dd>
<dt><strong><code>nH</code></strong> :&ensp;<code>float</code> or <code>int</code> or <code>list[float</code> or <code>int]</code></dt>
<dd>Hill coefficient for the given process. Indicates the degree of
cooperativity in the regulatory interaction.</dd>
<dt><strong><code>is_heterogeneous_K50</code></strong> :&ensp;<code>bool</code> or <code>list</code> of <code>bool</code></dt>
<dd>Denotes if the parameter <code>K50</code> exhibits heterogeneity
(distinct subspecies/interactions or normally-distributed).</dd>
<dt><strong><code>regulation_type</code></strong> :&ensp;<code>str</code> or <code>list</code> of <code>str</code></dt>
<dd>The type of regulation for this process based on the value of alpha:
'activation' or 'repression' or 'no regulation'.</dd>
<dt><strong><code>catalyst</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the species acting as a catalyst for this process.</dd>
<dt><strong><code>Km</code></strong> :&ensp;<code>float</code> or <code>int</code> or <code>list</code> of <code>floats</code> or <code>2-tuple</code> of <code>floats</code></dt>
<dd><em>Microscopic</em> Michaelis constant. Corresponds to the number
of <code>catalyst</code> agents that would produce half-maximal activity.
Heterogeneity in this parameter is determined by the type of <code>K50</code>,
using the same rules as for parameter <code>k</code>.</dd>
<dt><strong><code>is_heterogeneous_Km</code></strong> :&ensp;<code>bool</code></dt>
<dd>Denotes if the parameter <code>Km</code> exhibits heterogeneity
(distinct subspecies/interactions or normally-distributed).</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Currently only implemented for 1st order processes. 0th order processes
cannot obey Michaelis-Menten kinetics and 2nd order Michaelis-Menten
processes are not implemented yet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RegulatedMichaelisMentenProcess(RegulatedProcess):
    &#34;&#34;&#34; Define a process that is regulated and obeys Michaelis-Menten kinetics.

    This class allows a Michaelis-Menten Process to be defined
    in terms of how it is regulated.
    If there is only one regulating species, then the parameters have the same
    type as would be expected for a homogeneous/heterogeneous process.
    If there are multiple regulating species, then all parameters are a list
    of their expected type, with the length of the list being equal to the
    number of regulating species.

    Attributes
    ----------
    k : float or int or list of floats or 2-tuple of floats
        The *microscopic* rate constant for the given process. It is the *basal*
        rate constant in the case of activation (or the minimum `k` value)
        and the maximum rate constant in the case of repression.
    regulating_species : str or list of str
        Name of the regulating species. Multiple species can be specified as
        comma-separated in a string or a list of strings with the species names.
    alpha : float or int or list[float or int]
        Parameter denoting the degree of activation/repression.

            - 0 &lt;= alpha &lt; 1: repression
            - alpha = 1: no regulation
            - alpha &gt; 1: activation

        alpha is a multiplier: in the case of activation, the maximum
        rate constant value will be `alpha * k`.
        In the case of repression, the minimum
        rate constant value will be `alpha * k`.
    K50 : float or int or list of floats or 2-tuple of floats or list[float or int or list of floats or 2-tuple of floats]
        *Microscopic* constant that corresponds to the number of
        `regulating_species` agents that would produce
        half-maximal activation/repression.
        Heterogeneity in this parameter is determined by the type of `K50`,
        using the same rules as for parameter `k`.
    nH : float or int or list[float or int]
        Hill coefficient for the given process. Indicates the degree of
        cooperativity in the regulatory interaction.
    is_heterogeneous_K50 : bool or list of bool
        Denotes if the parameter `K50` exhibits heterogeneity
        (distinct subspecies/interactions or normally-distributed).
    regulation_type : str or list of str
        The type of regulation for this process based on the value of alpha:
        &#39;activation&#39; or &#39;repression&#39; or &#39;no regulation&#39;.
    catalyst : str
        Name of the species acting as a catalyst for this process.
    Km : float or int or list of floats or 2-tuple of floats
        *Microscopic* Michaelis constant. Corresponds to the number
        of `catalyst` agents that would produce half-maximal activity.
        Heterogeneity in this parameter is determined by the type of `K50`,
        using the same rules as for parameter `k`.
    is_heterogeneous_Km : bool
        Denotes if the parameter `Km` exhibits heterogeneity
        (distinct subspecies/interactions or normally-distributed).

    Notes
    -----
    Currently only implemented for 1st order processes. 0th order processes
    cannot obey Michaelis-Menten kinetics and 2nd order Michaelis-Menten
    processes are not implemented yet.
    &#34;&#34;&#34;

    def __init__(self, reactants: dict, products: dict,
                 k: float | int | list[float, ...] | tuple[float, float],
                 regulating_species: str | list[str, ...],
                 alpha: float | int | list[float | int, ...],
                 K50: float | int | list[float | int, ...] | tuple[float | int, float | int] |
                      list[float | int | list[float | int, ...] | tuple[float | int, float | int]],
                 nH: float | int | list[float | int, ...],
                 catalyst: str,
                 Km: float | int | list[float | int, ...] | tuple[float | int, float | int]):
        self.catalyst = catalyst
        self.Km = Km
        self.is_heterogeneous_Km = False if isinstance(self.Km, (int, float)) else True

        super().__init__(reactants, products, k, regulating_species, alpha, K50, nH)

        self.species.add(self.catalyst)
        self._str += f&#34;, catalyst = {self.catalyst}, Km = {self.Km}&#34;

        assert self.order != 0, &#34;A 0th order process has no substrate for a catalyst &#34; \
                                &#34;to act on, therefore it cannot follow Michaelis-Menten kinetics.&#34;
        if self.order == 2:
            raise NotImplementedError

    @classmethod
    def from_string(cls,
                    proc_str: str,
                    /,
                    k: float | int | list[float, ...] | tuple[float, float],
                    *,
                    regulating_species: str | list[str, ...] = None,
                    alpha: float | int | list[float | int, ...] = 1,
                    K50: float | int | list[float | int, ...] | tuple[float | int, float | int] |
                         list[float | int | list[float | int, ...] | tuple[
                             float | int, float | int]] = None,
                    nH: float | int | list[float | int, ...] = None,
                    catalyst: str = None,
                    Km: float | int | list[float | int, ...] | tuple[
                        float | int, float | int] = None,
                    sep: str = &#39;-&gt;&#39;) -&gt; Self:
        &#34;&#34;&#34; Create a regulated Michaelis-Menten process from a string.

        Parameters
        ----------
        proc_str : str
            A string describing the process in standard chemical notation
            (e.g., &#39;A + B -&gt; C&#39;)
        k : float or int or list of floats or 2-tuple of floats
            The *microscopic* rate constant for the given process. It is the *basal*
            rate constant in the case of activation (or the minimum `k` value)
            and the maximum rate constant in the case of repression.
            If `k` is a float or int, then the process is homogeneous.
            If `k` is a list, then the population of the reactants
            constsists of distinct subspecies or subinteractions
            depending on the order. If `k` is a 2-tuple,
            then the constant is normally-distributed with a mean and standard
            deviation specified in the tuple&#39;s elements. Note that `k` cannot
            be zero for this form of regulation.
        regulating_species : str or list of str
            Name of the regulating species.
        alpha : float or int or list[float or int]
            Parameter denoting the degree of activation/repression.

            - 0 &lt;= alpha &lt; 1: repression
            - alpha = 1: no regulation
            - alpha &gt; 1: activation

            alpha is a multiplier: in the case of activation, the maximum
            rate constant value will be `alpha * k`.
            In the case of repression, the minimum
            rate constant value will be `alpha * k`.
        K50 : float or int or list of floats or 2-tuple of floats or list of each of the previous types
            *Microscopic* constant that corresponds to the number of
            `regulating_species` agents that would produce
            half-maximal activation/repression.
            Heterogeneity in this parameter is determined by the type of `K50`,
            using the same rules as for parameter `k`.
        nH : float or int or list[float or int]
            Hill coefficient for the given process. Indicates the degree of
            cooperativity in the regulatory interaction.
        catalyst : str
            Name of species acting as a catalyst.
        Km : float or int or list of floats or 2-tuple of floats
            *Microscopic* Michaelis constant for the process.
            Heterogeneity in this parameter is determined by the type of `Km`,
            using the same rules as for parameter `k`.
        sep : str, default: &#39;-&gt;&#39;
            Specifies the characters that distinguish the reactants from the
            products. The default is &#39;-&gt;&#39;. The code also treats `--&gt;` as a
            default, if it&#39;s present in `proc_str`.

        Notes
        -----
        - Species names should not contain spaces, dashes, and
          should start with a non-numeric character.
        - Zeroth order processes should be specified by an empty space or &#39;None&#39;.

        Examples
        --------
        &gt;&gt;&gt; RegulatedMichaelisMentenProcess.from_string(&#34;A -&gt; X&#34;, k=0.2, regulating_species=&#39;X&#39;, alpha=2, K50=10, nH=1, catalyst=&#39;E&#39;, Km=15)
        &gt;&gt;&gt; RegulatedMichaelisMentenProcess.from_string(&#34;A -&gt; X&#34;, k=0.3, regulating_species=&#39;A&#39;, alpha=0.5, K50=[10, 15], nH=2, catalyst=&#39;C&#39;, Km=5)
        &#34;&#34;&#34;
        sep = &#39;--&gt;&#39; if &#39;--&gt;&#39; in proc_str else sep
        if sep not in proc_str:
            raise Exception(&#34;Cannot distinguish the reactants from the products.\n&#34;
                            &#34;Please use the *sep* keyword: e.g. sep=&#39;-&gt;&#39;.&#34;)

        lhs, rhs = proc_str.strip().split(sep)  # Left- and Right-hand sides of process
        lhs_terms = lhs.split(&#39;+&#39;)  # Separate the terms on the left-hand side
        rhs_terms = rhs.split(&#39;+&#39;)  # Separate the terms on the right-hand side

        return cls(cls._to_dict(lhs_terms), cls._to_dict(rhs_terms),
                   k,
                   regulating_species, alpha, K50, nH,
                   catalyst, Km)

    def __str__(self):
        if isinstance(self.regulating_species, list):
            K50_het_str = &#34;&#34;
            for i, sp in enumerate(self.regulating_species):
                if isinstance(self.K50[i], (float, int)):
                    K50_het_str += f&#34;Homogeneous process with respect to species {sp} K50. &#34;
                elif isinstance(self.K50[i], list):
                    K50_het_str += f&#34;Heterogeneous process with respect to species {sp} K50 &#34; \
                                   f&#34;with {len(self.K50[i])} distinct subspecies. &#34;
                else:
                    K50_het_str += f&#34;Heterogeneous process with normally-distributed &#34; \
                                   f&#34;species {sp} K50 with mean {self.K50[i][0]} and &#34; \
                                   f&#34;standard deviation {self.K50[i][1]}. &#34;
        else:
            if isinstance(self.K50, (float, int)):
                K50_het_str = &#34;Homogeneous process with respect to K50.&#34;
            elif isinstance(self.K50, list):
                K50_het_str = f&#34;Heterogeneous process with respect to K50 &#34; \
                              f&#34;with {len(self.K50)} distinct subspecies.&#34;
            else:
                K50_het_str = f&#34;Heterogeneous process with normally-distributed K50 with &#34; \
                              f&#34;mean {self.K50[0]} and standard deviation {self.K50[1]}.&#34;

        if isinstance(self.Km, (float, int)):
            Km_het_str = &#34;Homogeneous process with respect to Km.&#34;
        elif isinstance(self.k, list):
            Km_het_str = f&#34;Heterogeneous process with respect to Km &#34; \
                         f&#34;with {len(self.Km)} distinct subspecies.&#34;
        else:
            Km_het_str = f&#34;Heterogeneous process with normally-distributed Km with &#34; \
                         f&#34;mean {self.Km[0]} and standard deviation {self.Km[1]}.&#34;

        return super().__str__() + f&#34; Regulating Species: {self.regulating_species}, &#34; \
                                   f&#34;alpha = {self.alpha}, nH = {self.nH}, &#34; \
                                   f&#34;K50 = {self.K50}, {K50_het_str}, &#34; \
                                   f&#34;Catalyst: {self.catalyst}, &#34; \
                                   f&#34;Km = {self.Km}, {Km_het_str}&#34;

    def __repr__(self):
        return f&#34;RegulatedMichaelisMentenProcess Object: &#34; \
               f&#34;RegulatedMichaelisMentenProcess.from_string(&#39;{self._str.split(&#39;,&#39;)[0]}&#39;, &#34; \
               f&#34;k={self.k}, &#34; \
               f&#34;regulating_species=&#39;{self.regulating_species}&#39;, &#34; \
               f&#34;alpha={self.alpha}, &#34; \
               f&#34;K50={self.K50}, &#34; \
               f&#34;nH={self.nH}, &#34; \
               f&#34;catalyst={self.catalyst}, &#34; \
               f&#34;Km={self.Km})&#34;

    def __eq__(self, other):
        if isinstance(other, RegulatedMichaelisMentenProcess):
            is_equal = (self.k == other.k and
                        self.order == other.order and
                        self.reactants == other.reactants and
                        self.products == other.products and
                        self.regulating_species == other.regulating_species and
                        self.alpha == other.alpha and
                        self.K50 == other.K50 and
                        self.nH == other.nH and
                        self.catalyst == other.catalyst and
                        self.Km == other.Km and
                        self.species == other.species)
            return is_equal
        elif isinstance(other, str):
            return self._str == other or self._str.replace(&#39; &#39;, &#39;&#39;) == other
        else:
            print(f&#34;{type(self)} and {type(other)} are instances of different classes.&#34;)
            return False

    def __hash__(self):
        return hash(self._str)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="abstochkin.process.RegulatedProcess" href="#abstochkin.process.RegulatedProcess">RegulatedProcess</a></li>
<li><a title="abstochkin.process.Process" href="#abstochkin.process.Process">Process</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="abstochkin.process.RegulatedMichaelisMentenProcess.from_string"><code class="name flex">
<span>def <span class="ident">from_string</span></span>(<span>proc_str:str, /, k:float|int|list[float,...]|tuple[float,float], *, regulating_species:str|list[str,...]=None, alpha:float|int|list[float|int,...]=1, K50:float|int|list[float|int,...]|tuple[float|int,float|int]|list[float|int|list[float|int,...]|tuple[float|int,float|int]]=None, nH:float|int|list[float|int,...]=None, catalyst:str=None, Km:float|int|list[float|int,...]|tuple[float|int,float|int]=None, sep:str=&#x27;-&gt;&#x27;) >Self</span>
</code></dt>
<dd>
<div class="desc"><p>Create a regulated Michaelis-Menten process from a string.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>proc_str</code></strong> :&ensp;<code>str</code></dt>
<dd>A string describing the process in standard chemical notation
(e.g., 'A + B -&gt; C')</dd>
<dt><strong><code>k</code></strong> :&ensp;<code>float</code> or <code>int</code> or <code>list</code> of <code>floats</code> or <code>2-tuple</code> of <code>floats</code></dt>
<dd>The <em>microscopic</em> rate constant for the given process. It is the <em>basal</em>
rate constant in the case of activation (or the minimum <code>k</code> value)
and the maximum rate constant in the case of repression.
If <code>k</code> is a float or int, then the process is homogeneous.
If <code>k</code> is a list, then the population of the reactants
constsists of distinct subspecies or subinteractions
depending on the order. If <code>k</code> is a 2-tuple,
then the constant is normally-distributed with a mean and standard
deviation specified in the tuple's elements. Note that <code>k</code> cannot
be zero for this form of regulation.</dd>
<dt><strong><code>regulating_species</code></strong> :&ensp;<code>str</code> or <code>list</code> of <code>str</code></dt>
<dd>Name of the regulating species.</dd>
<dt><strong><code>alpha</code></strong> :&ensp;<code>float</code> or <code>int</code> or <code>list[float</code> or <code>int]</code></dt>
<dd>
<p>Parameter denoting the degree of activation/repression.</p>
<ul>
<li>0 &lt;= alpha &lt; 1: repression</li>
<li>alpha = 1: no regulation</li>
<li>alpha &gt; 1: activation</li>
</ul>
<p>alpha is a multiplier: in the case of activation, the maximum
rate constant value will be <code>alpha * k</code>.
In the case of repression, the minimum
rate constant value will be <code>alpha * k</code>.</p>
</dd>
<dt><strong><code>K50</code></strong> :&ensp;<code>float</code> or <code>int</code> or <code>list</code> of <code>floats</code> or <code>2-tuple</code> of <code>floats</code> or <code>list</code> of <code>each</code> of <code>the previous types</code></dt>
<dd><em>Microscopic</em> constant that corresponds to the number of
<code>regulating_species</code> agents that would produce
half-maximal activation/repression.
Heterogeneity in this parameter is determined by the type of <code>K50</code>,
using the same rules as for parameter <code>k</code>.</dd>
<dt><strong><code>nH</code></strong> :&ensp;<code>float</code> or <code>int</code> or <code>list[float</code> or <code>int]</code></dt>
<dd>Hill coefficient for the given process. Indicates the degree of
cooperativity in the regulatory interaction.</dd>
<dt><strong><code>catalyst</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of species acting as a catalyst.</dd>
<dt><strong><code>Km</code></strong> :&ensp;<code>float</code> or <code>int</code> or <code>list</code> of <code>floats</code> or <code>2-tuple</code> of <code>floats</code></dt>
<dd><em>Microscopic</em> Michaelis constant for the process.
Heterogeneity in this parameter is determined by the type of <code>Km</code>,
using the same rules as for parameter <code>k</code>.</dd>
<dt><strong><code>sep</code></strong> :&ensp;<code>str</code>, default<code>: '-&gt;'</code></dt>
<dd>Specifies the characters that distinguish the reactants from the
products. The default is '-&gt;'. The code also treats <code>--&gt;</code> as a
default, if it's present in <code>proc_str</code>.</dd>
</dl>
<h2 id="notes">Notes</h2>
<ul>
<li>Species names should not contain spaces, dashes, and
should start with a non-numeric character.</li>
<li>Zeroth order processes should be specified by an empty space or 'None'.</li>
</ul>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; RegulatedMichaelisMentenProcess.from_string(&quot;A -&gt; X&quot;, k=0.2, regulating_species='X', alpha=2, K50=10, nH=1, catalyst='E', Km=15)
&gt;&gt;&gt; RegulatedMichaelisMentenProcess.from_string(&quot;A -&gt; X&quot;, k=0.3, regulating_species='A', alpha=0.5, K50=[10, 15], nH=2, catalyst='C', Km=5)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_string(cls,
                proc_str: str,
                /,
                k: float | int | list[float, ...] | tuple[float, float],
                *,
                regulating_species: str | list[str, ...] = None,
                alpha: float | int | list[float | int, ...] = 1,
                K50: float | int | list[float | int, ...] | tuple[float | int, float | int] |
                     list[float | int | list[float | int, ...] | tuple[
                         float | int, float | int]] = None,
                nH: float | int | list[float | int, ...] = None,
                catalyst: str = None,
                Km: float | int | list[float | int, ...] | tuple[
                    float | int, float | int] = None,
                sep: str = &#39;-&gt;&#39;) -&gt; Self:
    &#34;&#34;&#34; Create a regulated Michaelis-Menten process from a string.

    Parameters
    ----------
    proc_str : str
        A string describing the process in standard chemical notation
        (e.g., &#39;A + B -&gt; C&#39;)
    k : float or int or list of floats or 2-tuple of floats
        The *microscopic* rate constant for the given process. It is the *basal*
        rate constant in the case of activation (or the minimum `k` value)
        and the maximum rate constant in the case of repression.
        If `k` is a float or int, then the process is homogeneous.
        If `k` is a list, then the population of the reactants
        constsists of distinct subspecies or subinteractions
        depending on the order. If `k` is a 2-tuple,
        then the constant is normally-distributed with a mean and standard
        deviation specified in the tuple&#39;s elements. Note that `k` cannot
        be zero for this form of regulation.
    regulating_species : str or list of str
        Name of the regulating species.
    alpha : float or int or list[float or int]
        Parameter denoting the degree of activation/repression.

        - 0 &lt;= alpha &lt; 1: repression
        - alpha = 1: no regulation
        - alpha &gt; 1: activation

        alpha is a multiplier: in the case of activation, the maximum
        rate constant value will be `alpha * k`.
        In the case of repression, the minimum
        rate constant value will be `alpha * k`.
    K50 : float or int or list of floats or 2-tuple of floats or list of each of the previous types
        *Microscopic* constant that corresponds to the number of
        `regulating_species` agents that would produce
        half-maximal activation/repression.
        Heterogeneity in this parameter is determined by the type of `K50`,
        using the same rules as for parameter `k`.
    nH : float or int or list[float or int]
        Hill coefficient for the given process. Indicates the degree of
        cooperativity in the regulatory interaction.
    catalyst : str
        Name of species acting as a catalyst.
    Km : float or int or list of floats or 2-tuple of floats
        *Microscopic* Michaelis constant for the process.
        Heterogeneity in this parameter is determined by the type of `Km`,
        using the same rules as for parameter `k`.
    sep : str, default: &#39;-&gt;&#39;
        Specifies the characters that distinguish the reactants from the
        products. The default is &#39;-&gt;&#39;. The code also treats `--&gt;` as a
        default, if it&#39;s present in `proc_str`.

    Notes
    -----
    - Species names should not contain spaces, dashes, and
      should start with a non-numeric character.
    - Zeroth order processes should be specified by an empty space or &#39;None&#39;.

    Examples
    --------
    &gt;&gt;&gt; RegulatedMichaelisMentenProcess.from_string(&#34;A -&gt; X&#34;, k=0.2, regulating_species=&#39;X&#39;, alpha=2, K50=10, nH=1, catalyst=&#39;E&#39;, Km=15)
    &gt;&gt;&gt; RegulatedMichaelisMentenProcess.from_string(&#34;A -&gt; X&#34;, k=0.3, regulating_species=&#39;A&#39;, alpha=0.5, K50=[10, 15], nH=2, catalyst=&#39;C&#39;, Km=5)
    &#34;&#34;&#34;
    sep = &#39;--&gt;&#39; if &#39;--&gt;&#39; in proc_str else sep
    if sep not in proc_str:
        raise Exception(&#34;Cannot distinguish the reactants from the products.\n&#34;
                        &#34;Please use the *sep* keyword: e.g. sep=&#39;-&gt;&#39;.&#34;)

    lhs, rhs = proc_str.strip().split(sep)  # Left- and Right-hand sides of process
    lhs_terms = lhs.split(&#39;+&#39;)  # Separate the terms on the left-hand side
    rhs_terms = rhs.split(&#39;+&#39;)  # Separate the terms on the right-hand side

    return cls(cls._to_dict(lhs_terms), cls._to_dict(rhs_terms),
               k,
               regulating_species, alpha, K50, nH,
               catalyst, Km)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="abstochkin.process.RegulatedProcess"><code class="flex name class">
<span>class <span class="ident">RegulatedProcess</span></span>
<span>(</span><span>reactants:dict, products:dict, k:float|int|list[float,...]|tuple[float,float], regulating_species:str|list[str,...], alpha:float|int|list[float|int,...], K50:float|int|list[float|int,...]|tuple[float|int,float|int]|list[float|int|list[float|int,...]|tuple[float|int,float|int]], nH:float|int|list[float|int,...])</span>
</code></dt>
<dd>
<div class="desc"><p>Define a process that is regulated.</p>
<p>This class allows a Process to be defined in terms of how it is regulated.
If there is only one regulating species, then the parameters have the same
type as would be expected for a homogeneous/heterogeneous process.
If there are multiple regulating species, then all parameters are a list
of their expected type, with the length of the list being equal to the
number of regulating species.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>k</code></strong> :&ensp;<code>float</code> or <code>int</code> or <code>list</code> of <code>floats</code> or <code>2-tuple</code> of <code>floats</code></dt>
<dd>The <em>microscopic</em> rate constant for the given process. It is the <em>basal</em>
rate constant in the case of activation (or the minimum <code>k</code> value)
and the maximum rate constant in the case of repression.</dd>
<dt><strong><code>regulating_species</code></strong> :&ensp;<code>str</code> or <code>list</code> of <code>str</code></dt>
<dd>Name of the regulating species. Multiple species can be specified as
comma-separated in a string or a list of strings with the species names.</dd>
<dt><strong><code>alpha</code></strong> :&ensp;<code>float</code> or <code>int</code> or <code>list[float</code> or <code>int]</code></dt>
<dd>
<p>Parameter denoting the degree of activation/repression.</p>
<pre><code>- 0 &lt;= alpha &lt; 1: repression
- alpha = 1: no regulation
- alpha &gt; 1: activation
</code></pre>
<p>alpha is a multiplier: in the case of activation, the maximum
rate constant value will be <code>alpha * k</code>.
In the case of repression, the minimum
rate constant value will be <code>alpha * k</code>.</p>
</dd>
<dt><strong><code>K50</code></strong> :&ensp;<code>float</code> or <code>int</code> or <code>list</code> of <code>floats</code> or <code>2-tuple</code> of <code>floats</code> or <code>list[float</code> or <code>int</code> or <code>list</code> of <code>floats</code> or <code>2-tuple</code> of <code>floats]</code></dt>
<dd><em>Microscopic</em> constant that corresponds to the number of
<code>regulating_species</code> agents that would produce
half-maximal activation/repression.
Heterogeneity in this parameter is determined by the type of <code>K50</code>,
using the same rules as for parameter <code>k</code>.</dd>
<dt><strong><code>nH</code></strong> :&ensp;<code>float</code> or <code>int</code> or <code>list[float</code> or <code>int]</code></dt>
<dd>Hill coefficient for the given process. Indicates the degree of
cooperativity in the regulatory interaction.</dd>
<dt><strong><code>is_heterogeneous_K50</code></strong> :&ensp;<code>bool</code> or <code>list</code> of <code>bool</code></dt>
<dd>Denotes if the parameter <code>K50</code> exhibits heterogeneity
(distinct subspecies/interactions or normally-distributed).</dd>
<dt><strong><code>regulation_type</code></strong> :&ensp;<code>str</code> or <code>list</code> of <code>str</code></dt>
<dd>The type of regulation for this process based on the value of alpha:
'activation' or 'repression' or 'no regulation'.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Allowing a 0th order process to be regulated. However, heterogeneity
in <code>k</code> and <code>K50</code> (or any other parameters) is not allowed for such
a process.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RegulatedProcess(Process):
    &#34;&#34;&#34; Define a process that is regulated.

    This class allows a Process to be defined in terms of how it is regulated.
    If there is only one regulating species, then the parameters have the same
    type as would be expected for a homogeneous/heterogeneous process.
    If there are multiple regulating species, then all parameters are a list
    of their expected type, with the length of the list being equal to the
    number of regulating species.
    
    Attributes
    ----------
    k : float or int or list of floats or 2-tuple of floats
        The *microscopic* rate constant for the given process. It is the *basal*
        rate constant in the case of activation (or the minimum `k` value)
        and the maximum rate constant in the case of repression.
    regulating_species : str or list of str
        Name of the regulating species. Multiple species can be specified as
        comma-separated in a string or a list of strings with the species names.
    alpha : float or int or list[float or int]
        Parameter denoting the degree of activation/repression.

            - 0 &lt;= alpha &lt; 1: repression
            - alpha = 1: no regulation
            - alpha &gt; 1: activation
            
        alpha is a multiplier: in the case of activation, the maximum 
        rate constant value will be `alpha * k`. 
        In the case of repression, the minimum 
        rate constant value will be `alpha * k`. 
    K50 : float or int or list of floats or 2-tuple of floats or list[float or int or list of floats or 2-tuple of floats]
        *Microscopic* constant that corresponds to the number of
        `regulating_species` agents that would produce 
        half-maximal activation/repression. 
        Heterogeneity in this parameter is determined by the type of `K50`,
        using the same rules as for parameter `k`.
    nH : float or int or list[float or int]
        Hill coefficient for the given process. Indicates the degree of 
        cooperativity in the regulatory interaction. 
    is_heterogeneous_K50 : bool or list of bool
        Denotes if the parameter `K50` exhibits heterogeneity
        (distinct subspecies/interactions or normally-distributed).
    regulation_type : str or list of str
        The type of regulation for this process based on the value of alpha:
        &#39;activation&#39; or &#39;repression&#39; or &#39;no regulation&#39;.

    Notes
    -----
    Allowing a 0th order process to be regulated. However, heterogeneity
    in `k` and `K50` (or any other parameters) is not allowed for such
    a process.
    &#34;&#34;&#34;

    def __init__(self, reactants: dict, products: dict,
                 k: float | int | list[float, ...] | tuple[float, float],
                 regulating_species: str | list[str, ...],
                 alpha: float | int | list[float | int, ...],
                 K50: float | int | list[float | int, ...] | tuple[float | int, float | int] |
                      list[float | int | list[float | int, ...] | tuple[float | int, float | int]],
                 nH: float | int | list[float | int, ...]):
        if isinstance(regulating_species, str):
            reg_sp_list = regulating_species.replace(&#39; &#39;, &#39;&#39;).split(&#39;,&#39;)
            self.regulating_species = reg_sp_list[0] if len(reg_sp_list) == 1 else reg_sp_list
        else:  # if it is a list
            self.regulating_species = regulating_species

        self.alpha = alpha
        self.K50 = K50
        self.nH = nH

        if isinstance(K50, list):
            self.is_heterogeneous_K50 = [False if isinstance(val, (int, float)) else True for val
                                         in K50]
        else:
            self.is_heterogeneous_K50 = False if isinstance(self.K50, (int, float)) else True

        super().__init__(reactants, products, k)

        self._str += f&#34;, regulating_species = {self.regulating_species}, alpha = {self.alpha}, &#34; \
                     f&#34;K50 = {self.K50}, nH = {self.nH}&#34;

        self._validate_reg_params()

        if isinstance(self.alpha, list):
            self.regulation_type = list()
            for a in self.alpha:
                reg_type = &#39;activation&#39; if a &gt; 1 else &#39;repression&#39; if a &lt; 1 else &#39;no regulation&#39;
                self.regulation_type.append(reg_type)
        else:
            self.regulation_type = &#39;activation&#39; if self.alpha &gt; 1 else &#39;repression&#39; if self.alpha &lt; 1 else &#39;no regulation&#39;

    def _validate_reg_params(self):
        &#34;&#34;&#34; Validate the parameters specific to the regulation. &#34;&#34;&#34;
        if isinstance(self.regulating_species, list):  # multiple regulating species
            # First check that the right number of values for each parameter are specified
            rs_num = len(self.regulating_species)
            msg = f&#34;Must specify {rs_num} # values when there are {rs_num} regulating species.&#34;
            assert len(self.alpha) == rs_num, msg.replace(&#39;#&#39;, &#39;alpha&#39;)
            assert len(self.K50) == rs_num, msg.replace(&#39;#&#39;, &#39;K50&#39;)
            assert len(self.nH) == rs_num, msg.replace(&#39;#&#39;, &#39;nH&#39;)

            for i in range(len(self.regulating_species)):
                assert self.alpha[i] &gt;= 0, &#34;The alpha parameter must be nonnegative.&#34;
                if self.alpha[i] == 1:
                    print(&#34;Warning: alpha=1 means the process is not regulated.&#34;)

                if isinstance(self.K50[i], (float, int)):
                    assert self.K50[i] &gt; 0, &#34;K50 has to be positive.&#34;
                elif isinstance(self.K50[i], list):
                    assert all([True if val &gt; 0 else False for val in self.K50[i]]), \
                        &#34;Subspecies K50 values have to be positive.&#34;
                else:  # isinstance(self.K50, tuple)
                    assert self.K50[i][0] &gt; 0 and self.K50[i][1] &gt; 0, \
                        &#34;Mean and std of K50 have to be positive.&#34;

                if self.order == 0:
                    assert not self.is_heterogeneous_K50[i], \
                        &#34;Heterogeneity in parameter K50 is not allowed for a 0th order process.&#34;

                assert self.nH[i] &gt; 0, &#34;nH has to be positive.&#34;

        else:  # just one regulating species
            assert self.alpha &gt;= 0, &#34;The alpha parameter must be nonnegative.&#34;
            if self.alpha == 1:
                print(&#34;Warning: alpha=1 means the process is not regulated.&#34;)

            if isinstance(self.K50, (float, int)):
                assert self.K50 &gt; 0, &#34;K50 has to be positive.&#34;
            elif isinstance(self.K50, list):
                assert all([True if val &gt; 0 else False for val in self.K50]), \
                    &#34;Subspecies K50 values have to be positive.&#34;
            else:  # isinstance(self.K50, tuple)
                assert self.K50[0] &gt; 0 and self.K50[1] &gt; 0, \
                    &#34;Mean and std of K50 have to be positive.&#34;

            if self.order == 0:
                assert not self.is_heterogeneous_K50, \
                    &#34;Heterogeneity in parameter K50 is not allowed for a 0th order process.&#34;

            assert self.nH &gt; 0, &#34;nH has to be positive.&#34;

    @classmethod
    def from_string(cls,
                    proc_str: str,
                    /,
                    k: float | int | list[float, ...] | tuple[float, float],
                    *,
                    regulating_species: str | list[str, ...] = None,
                    alpha: float | int | list[float | int, ...] = 1,
                    K50: float | int | list[float | int, ...] | tuple[float | int, float | int] |
                         list[float | int | list[float | int, ...] | tuple[
                             float | int, float | int]] = None,
                    nH: float | int | list[float | int, ...] = None,
                    sep: str = &#39;-&gt;&#39;) -&gt; Self:
        &#34;&#34;&#34; Create a regulated process from a string.

        Parameters
        ----------
        proc_str : str
            A string describing the process in standard chemical notation
            (e.g., &#39;A + B -&gt; C&#39;)
        k : float or int or list of floats or 2-tuple of floats
            The *microscopic* rate constant for the given process. It is the *basal*
            rate constant in the case of activation (or the minimum `k` value) 
            and the maximum rate constant in the case of repression. 
            If `k` is a float or int, then the process is homogeneous. 
            If `k` is a list, then the population of the reactants 
            constsists of distinct subspecies or subinteractions 
            depending on the order. If `k` is a 2-tuple,
            then the constant is normally-distributed with a mean and standard
            deviation specified in the tuple&#39;s elements. Note that `k` cannot
            be zero for this form of regulation.
        regulating_species : str or list of str
            Name of the regulating species.
        alpha : float or int or list[float or int]
            Parameter denoting the degree of activation/repression.

                - 0 &lt;= alpha &lt; 1: repression
                - alpha = 1: no regulation
                - alpha &gt; 1: activation
                
            alpha is a multiplier: in the case of activation, the maximum 
            rate constant value will be `alpha * k`. 
            In the case of repression, the minimum 
            rate constant value will be `alpha * k`. 
        K50 : float or int or list of floats or 2-tuple of floats or list of each of the previous types
            *Microscopic* constant that corresponds to the number of
            `regulating_species` agents that would produce 
            half-maximal activation/repression. 
            Heterogeneity in this parameter is determined by the type of `K50`,
            using the same rules as for parameter `k`.
        nH : float or int or list[float or int]
            Hill coefficient for the given process. Indicates the degree of 
            cooperativity in the regulatory interaction. 
        sep : str, default: &#39;-&gt;&#39;
            Specifies the characters that distinguish the reactants from the
            products. The default is &#39;-&gt;&#39;. The code also treats `--&gt;` as a
            default, if it&#39;s present in `proc_str`.

        Notes
        -----
        - Species names should not contain spaces, dashes, and
          should start with a non-numeric character.
        - Zeroth order processes should be specified by an empty space or &#39;None&#39;.

        Examples
        --------
        &gt;&gt;&gt; RegulatedProcess.from_string(&#34;A -&gt; X&#34;, k=0.2, regulating_species=&#39;X&#39;, alpha=2, K50=10, nH=1)
        &gt;&gt;&gt; RegulatedProcess.from_string(&#34;A -&gt; X&#34;, k=0.3, regulating_species=&#39;X&#39;, alpha=0.5, K50=[10, 15], nH=2)
        &gt;&gt;&gt; RegulatedProcess.from_string(&#34;A + B -&gt; X&#34;, k=0.5, regulating_species=&#39;B, X&#39;, alpha=[2, 0], K50=[(15, 5), [10, 15]], nH=[1, 2])
        &#34;&#34;&#34;
        sep = &#39;--&gt;&#39; if &#39;--&gt;&#39; in proc_str else sep
        if sep not in proc_str:
            raise Exception(&#34;Cannot distinguish the reactants from the products.\n&#34;
                            &#34;Please use the *sep* keyword: e.g. sep=&#39;-&gt;&#39;.&#34;)

        lhs, rhs = proc_str.strip().split(sep)  # Left- and Right-hand sides of process
        lhs_terms = lhs.split(&#39;+&#39;)  # Separate the terms on the left-hand side
        rhs_terms = rhs.split(&#39;+&#39;)  # Separate the terms on the right-hand side

        return cls(cls._to_dict(lhs_terms), cls._to_dict(rhs_terms),
                   k,
                   regulating_species, alpha, K50, nH)

    def __str__(self):
        if isinstance(self.regulating_species, list):
            K50_het_str = &#34;&#34;
            for i, sp in enumerate(self.regulating_species):
                if isinstance(self.K50[i], (float, int)):
                    K50_het_str += f&#34;Homogeneous process with respect to species {sp} K50. &#34;
                elif isinstance(self.K50[i], list):
                    K50_het_str += f&#34;Heterogeneous process with respect to species {sp} K50 &#34; \
                                   f&#34;with {len(self.K50[i])} distinct subspecies. &#34;
                else:
                    K50_het_str += f&#34;Heterogeneous process with normally-distributed &#34; \
                                   f&#34;species {sp} K50 with mean {self.K50[i][0]} and &#34; \
                                   f&#34;standard deviation {self.K50[i][1]}. &#34;
        else:
            if isinstance(self.K50, (float, int)):
                K50_het_str = &#34;Homogeneous process with respect to K50.&#34;
            elif isinstance(self.K50, list):
                K50_het_str = f&#34;Heterogeneous process with respect to K50 &#34; \
                              f&#34;with {len(self.K50)} distinct subspecies.&#34;
            else:
                K50_het_str = f&#34;Heterogeneous process with normally-distributed K50 with &#34; \
                              f&#34;mean {self.K50[0]} and standard deviation {self.K50[1]}.&#34;

        return super().__str__() + f&#34; Regulating Species: {self.regulating_species}, &#34; \
                                   f&#34;alpha = {self.alpha}, nH = {self.nH}, &#34; \
                                   f&#34;K50 = {self.K50}, {K50_het_str}&#34;

    def __repr__(self):
        return f&#34;RegulatedProcess Object: &#34; \
               f&#34;RegulatedProcess.from_string(&#39;{self._str.split(&#39;,&#39;)[0]}&#39;, &#34; \
               f&#34;k={self.k}, &#34; \
               f&#34;regulating_species=&#39;{self.regulating_species}&#39;, &#34; \
               f&#34;alpha={self.alpha}, &#34; \
               f&#34;K50={self.K50}, &#34; \
               f&#34;nH={self.nH})&#34;

    def __eq__(self, other):
        if isinstance(other, RegulatedProcess):
            is_equal = (self.k == other.k and
                        self.order == other.order and
                        self.reactants == other.reactants and
                        self.products == other.products and
                        self.regulating_species == other.regulating_species and
                        self.alpha == other.alpha and
                        self.K50 == other.K50 and
                        self.nH == other.nH and
                        self.species == other.species)
            return is_equal
        elif isinstance(other, str):
            return self._str == other or self._str.replace(&#39; &#39;, &#39;&#39;) == other
        else:
            print(f&#34;{type(self)} and {type(other)} are instances of different classes.&#34;)
            return False

    def __hash__(self):
        return hash(self._str)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="abstochkin.process.Process" href="#abstochkin.process.Process">Process</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="abstochkin.process.RegulatedMichaelisMentenProcess" href="#abstochkin.process.RegulatedMichaelisMentenProcess">RegulatedMichaelisMentenProcess</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="abstochkin.process.RegulatedProcess.from_string"><code class="name flex">
<span>def <span class="ident">from_string</span></span>(<span>proc_str:str, /, k:float|int|list[float,...]|tuple[float,float], *, regulating_species:str|list[str,...]=None, alpha:float|int|list[float|int,...]=1, K50:float|int|list[float|int,...]|tuple[float|int,float|int]|list[float|int|list[float|int,...]|tuple[float|int,float|int]]=None, nH:float|int|list[float|int,...]=None, sep:str=&#x27;-&gt;&#x27;) >Self</span>
</code></dt>
<dd>
<div class="desc"><p>Create a regulated process from a string.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>proc_str</code></strong> :&ensp;<code>str</code></dt>
<dd>A string describing the process in standard chemical notation
(e.g., 'A + B -&gt; C')</dd>
<dt><strong><code>k</code></strong> :&ensp;<code>float</code> or <code>int</code> or <code>list</code> of <code>floats</code> or <code>2-tuple</code> of <code>floats</code></dt>
<dd>The <em>microscopic</em> rate constant for the given process. It is the <em>basal</em>
rate constant in the case of activation (or the minimum <code>k</code> value)
and the maximum rate constant in the case of repression.
If <code>k</code> is a float or int, then the process is homogeneous.
If <code>k</code> is a list, then the population of the reactants
constsists of distinct subspecies or subinteractions
depending on the order. If <code>k</code> is a 2-tuple,
then the constant is normally-distributed with a mean and standard
deviation specified in the tuple's elements. Note that <code>k</code> cannot
be zero for this form of regulation.</dd>
<dt><strong><code>regulating_species</code></strong> :&ensp;<code>str</code> or <code>list</code> of <code>str</code></dt>
<dd>Name of the regulating species.</dd>
<dt><strong><code>alpha</code></strong> :&ensp;<code>float</code> or <code>int</code> or <code>list[float</code> or <code>int]</code></dt>
<dd>
<p>Parameter denoting the degree of activation/repression.</p>
<pre><code>- 0 &lt;= alpha &lt; 1: repression
- alpha = 1: no regulation
- alpha &gt; 1: activation
</code></pre>
<p>alpha is a multiplier: in the case of activation, the maximum
rate constant value will be <code>alpha * k</code>.
In the case of repression, the minimum
rate constant value will be <code>alpha * k</code>.</p>
</dd>
<dt><strong><code>K50</code></strong> :&ensp;<code>float</code> or <code>int</code> or <code>list</code> of <code>floats</code> or <code>2-tuple</code> of <code>floats</code> or <code>list</code> of <code>each</code> of <code>the previous types</code></dt>
<dd><em>Microscopic</em> constant that corresponds to the number of
<code>regulating_species</code> agents that would produce
half-maximal activation/repression.
Heterogeneity in this parameter is determined by the type of <code>K50</code>,
using the same rules as for parameter <code>k</code>.</dd>
<dt><strong><code>nH</code></strong> :&ensp;<code>float</code> or <code>int</code> or <code>list[float</code> or <code>int]</code></dt>
<dd>Hill coefficient for the given process. Indicates the degree of
cooperativity in the regulatory interaction.</dd>
<dt><strong><code>sep</code></strong> :&ensp;<code>str</code>, default<code>: '-&gt;'</code></dt>
<dd>Specifies the characters that distinguish the reactants from the
products. The default is '-&gt;'. The code also treats <code>--&gt;</code> as a
default, if it's present in <code>proc_str</code>.</dd>
</dl>
<h2 id="notes">Notes</h2>
<ul>
<li>Species names should not contain spaces, dashes, and
should start with a non-numeric character.</li>
<li>Zeroth order processes should be specified by an empty space or 'None'.</li>
</ul>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; RegulatedProcess.from_string(&quot;A -&gt; X&quot;, k=0.2, regulating_species='X', alpha=2, K50=10, nH=1)
&gt;&gt;&gt; RegulatedProcess.from_string(&quot;A -&gt; X&quot;, k=0.3, regulating_species='X', alpha=0.5, K50=[10, 15], nH=2)
&gt;&gt;&gt; RegulatedProcess.from_string(&quot;A + B -&gt; X&quot;, k=0.5, regulating_species='B, X', alpha=[2, 0], K50=[(15, 5), [10, 15]], nH=[1, 2])
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_string(cls,
                proc_str: str,
                /,
                k: float | int | list[float, ...] | tuple[float, float],
                *,
                regulating_species: str | list[str, ...] = None,
                alpha: float | int | list[float | int, ...] = 1,
                K50: float | int | list[float | int, ...] | tuple[float | int, float | int] |
                     list[float | int | list[float | int, ...] | tuple[
                         float | int, float | int]] = None,
                nH: float | int | list[float | int, ...] = None,
                sep: str = &#39;-&gt;&#39;) -&gt; Self:
    &#34;&#34;&#34; Create a regulated process from a string.

    Parameters
    ----------
    proc_str : str
        A string describing the process in standard chemical notation
        (e.g., &#39;A + B -&gt; C&#39;)
    k : float or int or list of floats or 2-tuple of floats
        The *microscopic* rate constant for the given process. It is the *basal*
        rate constant in the case of activation (or the minimum `k` value) 
        and the maximum rate constant in the case of repression. 
        If `k` is a float or int, then the process is homogeneous. 
        If `k` is a list, then the population of the reactants 
        constsists of distinct subspecies or subinteractions 
        depending on the order. If `k` is a 2-tuple,
        then the constant is normally-distributed with a mean and standard
        deviation specified in the tuple&#39;s elements. Note that `k` cannot
        be zero for this form of regulation.
    regulating_species : str or list of str
        Name of the regulating species.
    alpha : float or int or list[float or int]
        Parameter denoting the degree of activation/repression.

            - 0 &lt;= alpha &lt; 1: repression
            - alpha = 1: no regulation
            - alpha &gt; 1: activation
            
        alpha is a multiplier: in the case of activation, the maximum 
        rate constant value will be `alpha * k`. 
        In the case of repression, the minimum 
        rate constant value will be `alpha * k`. 
    K50 : float or int or list of floats or 2-tuple of floats or list of each of the previous types
        *Microscopic* constant that corresponds to the number of
        `regulating_species` agents that would produce 
        half-maximal activation/repression. 
        Heterogeneity in this parameter is determined by the type of `K50`,
        using the same rules as for parameter `k`.
    nH : float or int or list[float or int]
        Hill coefficient for the given process. Indicates the degree of 
        cooperativity in the regulatory interaction. 
    sep : str, default: &#39;-&gt;&#39;
        Specifies the characters that distinguish the reactants from the
        products. The default is &#39;-&gt;&#39;. The code also treats `--&gt;` as a
        default, if it&#39;s present in `proc_str`.

    Notes
    -----
    - Species names should not contain spaces, dashes, and
      should start with a non-numeric character.
    - Zeroth order processes should be specified by an empty space or &#39;None&#39;.

    Examples
    --------
    &gt;&gt;&gt; RegulatedProcess.from_string(&#34;A -&gt; X&#34;, k=0.2, regulating_species=&#39;X&#39;, alpha=2, K50=10, nH=1)
    &gt;&gt;&gt; RegulatedProcess.from_string(&#34;A -&gt; X&#34;, k=0.3, regulating_species=&#39;X&#39;, alpha=0.5, K50=[10, 15], nH=2)
    &gt;&gt;&gt; RegulatedProcess.from_string(&#34;A + B -&gt; X&#34;, k=0.5, regulating_species=&#39;B, X&#39;, alpha=[2, 0], K50=[(15, 5), [10, 15]], nH=[1, 2])
    &#34;&#34;&#34;
    sep = &#39;--&gt;&#39; if &#39;--&gt;&#39; in proc_str else sep
    if sep not in proc_str:
        raise Exception(&#34;Cannot distinguish the reactants from the products.\n&#34;
                        &#34;Please use the *sep* keyword: e.g. sep=&#39;-&gt;&#39;.&#34;)

    lhs, rhs = proc_str.strip().split(sep)  # Left- and Right-hand sides of process
    lhs_terms = lhs.split(&#39;+&#39;)  # Separate the terms on the left-hand side
    rhs_terms = rhs.split(&#39;+&#39;)  # Separate the terms on the right-hand side

    return cls(cls._to_dict(lhs_terms), cls._to_dict(rhs_terms),
               k,
               regulating_species, alpha, K50, nH)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="abstochkin.process.ReversibleProcess"><code class="flex name class">
<span>class <span class="ident">ReversibleProcess</span></span>
<span>(</span><span>reactants:dict, products:dict, k:float|int|list[float,...]|tuple[float,float], k_rev:float|int|list[float,...]|tuple[float,float])</span>
</code></dt>
<dd>
<div class="desc"><p>Define a reversible process.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>k_rev</code></strong> :&ensp;<code>float</code> or <code>int</code> or <code>list</code> of <code>floats</code> or <code>2-tuple</code> of <code>floats</code></dt>
<dd>The <em>microscopic</em> rate constant for the reverse process.</dd>
<dt><strong><code>is_heterogeneous_rev</code></strong> :&ensp;<code>bool</code></dt>
<dd>Denotes if the parameter <code>k_rev</code> exhibits heterogeneity
(distinct subspecies/interactions or normally-distributed).</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>A ReversibleProcess object gets split into two Process objects
(forward and reverse process) when the algorithm runs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReversibleProcess(Process):
    &#34;&#34;&#34; Define a reversible process.

    Attributes
    ----------
    k_rev : float or int or list of floats or 2-tuple of floats
        The *microscopic* rate constant for the reverse process.
    is_heterogeneous_rev : bool
        Denotes if the parameter `k_rev` exhibits heterogeneity
        (distinct subspecies/interactions or normally-distributed).

    Notes
    -----
    A ReversibleProcess object gets split into two Process objects
    (forward and reverse process) when the algorithm runs.
    &#34;&#34;&#34;

    def __init__(self, reactants: dict, products: dict,
                 k: float | int | list[float, ...] | tuple[float, float],
                 k_rev: float | int | list[float, ...] | tuple[float, float]):
        self.k_rev = k_rev  # rate constant for reverse process
        self.is_heterogeneous_rev = False if isinstance(self.k_rev, (int, float)) else True

        super().__init__(reactants, products, k)

        self.order_rev = sum(self.products.values())

    @classmethod
    def from_string(cls,
                    proc_str: str,
                    /,
                    k: float | int | list[float, ...] | tuple[float, float],
                    *,
                    k_rev: float | int | list[float, ...] | tuple[float, float] = 0,
                    sep: str = &#39;&lt;-&gt;&#39;) -&gt; Self:
        &#34;&#34;&#34; Create a reversible process from a string.

        Parameters
        ----------
        proc_str : str
            A string describing the process in standard chemical notation
            (e.g., &#39;A + B &lt;-&gt; C&#39;)
        k : float or int or list of floats or 2-tuple of floats
            The *microscopic* rate constant for the forward process.
        k_rev : float or int or list of floats or 2-tuple of floats
            The *microscopic* rate constant for the reverse process.
        sep : str, default: &#39;&lt;-&gt;&#39;
            Specifies the characters that distinguish the reactants from the
            products. The default is &#39;&lt;-&gt;&#39;. The code also treats `&lt;--&gt;` as a
            default, if it&#39;s present in `proc_str`.

        Notes
        -----
        - Species names should not contain spaces, dashes, and
          should start with a non-numeric character.

        Examples
        --------
        &gt;&gt;&gt; ReversibleProcess.from_string(&#34;2A + B &lt;-&gt; X&#34;, 0.3, k_rev=0.2)
        &#34;&#34;&#34;
        for s in [&#39;&lt;--&gt;&#39;, &#39;&lt;=&gt;&#39;, &#39;&lt;==&gt;&#39;]:
            sep = s if s in proc_str else sep
        if sep not in proc_str:
            raise Exception(&#34;Cannot distinguish the reactants from the products.\n&#34;
                            &#34;Please use the *sep* keyword: e.g. sep=&#39;&lt;-&gt;&#39;.&#34;)

        lhs, rhs = proc_str.strip().split(sep)  # Left- and Right-hand sides of process
        lhs_terms = lhs.split(&#39;+&#39;)  # Separate the terms on the left-hand side
        rhs_terms = rhs.split(&#39;+&#39;)  # Separate the terms on the right-hand side

        return cls(cls._to_dict(lhs_terms), cls._to_dict(rhs_terms),
                   k, k_rev)

    def __repr__(self):
        return f&#34;ReversibleProcess Object: ReversibleProcess.from_string(&#34; \
               f&#34;&#39;{self._str.split(&#39;,&#39;)[0]}&#39;, k={self.k}, k_rev={self.k_rev})&#34;

    def __str__(self):
        if isinstance(self.k, (float, int)):
            het_str = &#34;Forward homogeneous process.&#34;
        elif isinstance(self.k, list):
            het_str = f&#34;Forward heterogeneous process with {len(self.k)} &#34; \
                      f&#34;distinct subspecies.&#34;
        else:
            het_str = f&#34;Forward heterogeneous process with normally-distributed &#34; \
                      f&#34;k with mean {self.k[0]} and standard deviation {self.k[1]}.&#34;

        if isinstance(self.k_rev, (float, int)):
            het_rev_str = &#34;Reverse homogeneous process.&#34;
        elif isinstance(self.k_rev, list):
            het_rev_str = f&#34;Reverse heterogeneous process with {len(self.k_rev)} &#34; \
                          f&#34;distinct subspecies.&#34;
        else:
            het_rev_str = f&#34;Reverse heterogeneous process with normally-distributed &#34; \
                          f&#34;k with mean {self.k_rev[0]} and standard deviation {self.k_rev[1]}.&#34;

        lhs, rhs = self._reconstruct_string()
        return &#34; &lt;-&gt; &#34;.join([lhs, rhs]) + f&#34;, k = {self.k}, k_rev = {self.k_rev}; &#34; \
                                          f&#34;{het_str} {het_rev_str}&#34;

    def _reconstruct_string(self):
        lhs = &#39; + &#39;.join([f&#34;{str(val) + &#39; &#39; if val not in [0, 1] else &#39;&#39;}{key}&#34; for key, val in
                          self.reactants.items()])
        rhs = &#39; + &#39;.join([f&#34;{str(val) + &#39; &#39; if val not in [0, 1] else &#39;&#39;}{key}&#34; for key, val in
                          self.products.items()])
        return lhs, rhs

    def __eq__(self, other):
        if isinstance(other, ReversibleProcess):
            is_equal = (self.k == other.k and
                        self.order == other.order and
                        self.k_rev == other.k_rev and
                        self.order_rev == other.order_rev and
                        self.reactants == other.reactants and
                        self.products == other.products and
                        self.species == other.species)
            return is_equal
        elif isinstance(other, str):
            return self._str == other or self._str.replace(&#39; &#39;, &#39;&#39;) == other
        else:
            print(f&#34;{type(self)} and {type(other)} are instances of different classes.&#34;)
            return False

    def __hash__(self):
        return hash(self._str)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="abstochkin.process.Process" href="#abstochkin.process.Process">Process</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="abstochkin.process.ReversibleProcess.from_string"><code class="name flex">
<span>def <span class="ident">from_string</span></span>(<span>proc_str:str, /, k:float|int|list[float,...]|tuple[float,float], *, k_rev:float|int|list[float,...]|tuple[float,float]=0, sep:str=&#x27;&lt;-&gt;&#x27;) >Self</span>
</code></dt>
<dd>
<div class="desc"><p>Create a reversible process from a string.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>proc_str</code></strong> :&ensp;<code>str</code></dt>
<dd>A string describing the process in standard chemical notation
(e.g., 'A + B &lt;-&gt; C')</dd>
<dt><strong><code>k</code></strong> :&ensp;<code>float</code> or <code>int</code> or <code>list</code> of <code>floats</code> or <code>2-tuple</code> of <code>floats</code></dt>
<dd>The <em>microscopic</em> rate constant for the forward process.</dd>
<dt><strong><code>k_rev</code></strong> :&ensp;<code>float</code> or <code>int</code> or <code>list</code> of <code>floats</code> or <code>2-tuple</code> of <code>floats</code></dt>
<dd>The <em>microscopic</em> rate constant for the reverse process.</dd>
<dt><strong><code>sep</code></strong> :&ensp;<code>str</code>, default<code>: '&lt;-&gt;'</code></dt>
<dd>Specifies the characters that distinguish the reactants from the
products. The default is '&lt;-&gt;'. The code also treats <code>&lt;--&gt;</code> as a
default, if it's present in <code>proc_str</code>.</dd>
</dl>
<h2 id="notes">Notes</h2>
<ul>
<li>Species names should not contain spaces, dashes, and
should start with a non-numeric character.</li>
</ul>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; ReversibleProcess.from_string(&quot;2A + B &lt;-&gt; X&quot;, 0.3, k_rev=0.2)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_string(cls,
                proc_str: str,
                /,
                k: float | int | list[float, ...] | tuple[float, float],
                *,
                k_rev: float | int | list[float, ...] | tuple[float, float] = 0,
                sep: str = &#39;&lt;-&gt;&#39;) -&gt; Self:
    &#34;&#34;&#34; Create a reversible process from a string.

    Parameters
    ----------
    proc_str : str
        A string describing the process in standard chemical notation
        (e.g., &#39;A + B &lt;-&gt; C&#39;)
    k : float or int or list of floats or 2-tuple of floats
        The *microscopic* rate constant for the forward process.
    k_rev : float or int or list of floats or 2-tuple of floats
        The *microscopic* rate constant for the reverse process.
    sep : str, default: &#39;&lt;-&gt;&#39;
        Specifies the characters that distinguish the reactants from the
        products. The default is &#39;&lt;-&gt;&#39;. The code also treats `&lt;--&gt;` as a
        default, if it&#39;s present in `proc_str`.

    Notes
    -----
    - Species names should not contain spaces, dashes, and
      should start with a non-numeric character.

    Examples
    --------
    &gt;&gt;&gt; ReversibleProcess.from_string(&#34;2A + B &lt;-&gt; X&#34;, 0.3, k_rev=0.2)
    &#34;&#34;&#34;
    for s in [&#39;&lt;--&gt;&#39;, &#39;&lt;=&gt;&#39;, &#39;&lt;==&gt;&#39;]:
        sep = s if s in proc_str else sep
    if sep not in proc_str:
        raise Exception(&#34;Cannot distinguish the reactants from the products.\n&#34;
                        &#34;Please use the *sep* keyword: e.g. sep=&#39;&lt;-&gt;&#39;.&#34;)

    lhs, rhs = proc_str.strip().split(sep)  # Left- and Right-hand sides of process
    lhs_terms = lhs.split(&#39;+&#39;)  # Separate the terms on the left-hand side
    rhs_terms = rhs.split(&#39;+&#39;)  # Separate the terms on the right-hand side

    return cls(cls._to_dict(lhs_terms), cls._to_dict(rhs_terms),
               k, k_rev)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<form>
<input id="lunr-search" name="q" placeholder=" Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="abstochkin" href="index.html">abstochkin</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="abstochkin.process.update_all_species" href="#abstochkin.process.update_all_species">update_all_species</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="abstochkin.process.MichaelisMentenProcess" href="#abstochkin.process.MichaelisMentenProcess">MichaelisMentenProcess</a></code></h4>
<ul class="">
<li><code><a title="abstochkin.process.MichaelisMentenProcess.from_string" href="#abstochkin.process.MichaelisMentenProcess.from_string">from_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="abstochkin.process.NullSpeciesNameError" href="#abstochkin.process.NullSpeciesNameError">NullSpeciesNameError</a></code></h4>
</li>
<li>
<h4><code><a title="abstochkin.process.Process" href="#abstochkin.process.Process">Process</a></code></h4>
<ul class="">
<li><code><a title="abstochkin.process.Process.from_string" href="#abstochkin.process.Process.from_string">from_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="abstochkin.process.RegulatedMichaelisMentenProcess" href="#abstochkin.process.RegulatedMichaelisMentenProcess">RegulatedMichaelisMentenProcess</a></code></h4>
<ul class="">
<li><code><a title="abstochkin.process.RegulatedMichaelisMentenProcess.from_string" href="#abstochkin.process.RegulatedMichaelisMentenProcess.from_string">from_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="abstochkin.process.RegulatedProcess" href="#abstochkin.process.RegulatedProcess">RegulatedProcess</a></code></h4>
<ul class="">
<li><code><a title="abstochkin.process.RegulatedProcess.from_string" href="#abstochkin.process.RegulatedProcess.from_string">from_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="abstochkin.process.ReversibleProcess" href="#abstochkin.process.ReversibleProcess">ReversibleProcess</a></code></h4>
<ul class="">
<li><code><a title="abstochkin.process.ReversibleProcess.from_string" href="#abstochkin.process.ReversibleProcess.from_string">from_string</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
 Copyright 2024, Alex Plakantonakis.
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>