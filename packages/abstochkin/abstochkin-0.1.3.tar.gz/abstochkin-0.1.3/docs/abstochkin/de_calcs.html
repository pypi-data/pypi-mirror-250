<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>abstochkin.de_calcs API documentation</title>
<meta name="description" content="Perform deterministic calculations on a set of processes.
Construct the ordinary differential equations (ODEs)
describing the system and obtain a â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>abstochkin.de_calcs</code></h1>
</header>
<section id="section-intro">
<p>Perform deterministic calculations on a set of processes.
Construct the ordinary differential equations (ODEs)
describing the system and obtain a numerical solution.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Perform deterministic calculations on a set of processes.
Construct the ordinary differential equations (ODEs)
describing the system and obtain a numerical solution.
&#34;&#34;&#34;

#  Copyright (c) 2023, Alex Plakantonakis.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

from numpy import mean
from scipy.integrate import solve_ivp
from sympy import Add, Mul, Pow, sympify, lambdify, symbols
# We want all single-letter and Greek-letter variables to be symbols.
# We can then use the clashing-symbols dictionaries that have been defined
# as private variables in `_clash` (which includes both single and
# multi-letter names that are defined in `sympy.abc`).
from sympy.abc import _clash

from .process import update_all_species, MichaelisMentenProcess, RegulatedProcess, \
    RegulatedMichaelisMentenProcess


class DEcalcs:
    &#34;&#34;&#34;
    Perform deterministic calculations given the processes specified
    in an AbStochKin simulation object.

    Attributes
    ----------
    p0 : dict[str: int]
        Dictionary specifying the initial population sizes of all
        species in the given processes.
    t_min : float or int
        Numerical value of the start of simulated time in the units
        specified in the class attribute `time_unit`.
    t_max : float or int
        Numerical value of the end of simulated time in the units
        specified in the class attribute `time_unit`.
    processes : list of Process objects
        A list of all the processes that define the system of ODEs.
        Each process is a `Process` object.
    ode_method: str
        Method for the ODE solver to use.
    time_unit: str
        A string of the time unit to be used for describing the
        kinetics of the given processes.
    &#34;&#34;&#34;

    def __init__(self,
                 p0: dict,
                 t_min: int | float,
                 t_max: int | float,
                 processes: list,
                 ode_method: str,
                 time_unit: str):
        self.p0 = p0
        self.t_min = t_min
        self.t_max = t_max
        self.processes = processes
        self.ode_method = ode_method
        self.time_unit = time_unit

        # *** For computing and storing the solution to the system of ODEs. ***
        self._all_species, self._procs_by_reactant, self._procs_by_product = update_all_species(
            tuple(self.processes))
        self.odes = dict()  # store species-specific ODEs
        self.odes_sol = None  # numerical solution of species trajectories

        self.species_with_ode = list()
        self.jac = None  # Jacobian matrix
        self.fixed_pts = dict()  # dictionary of fixed points

        self.setup_ODEs()
        self.get_fixed_pts()

    def setup_ODEs(self, agent_based=True):
        &#34;&#34;&#34;
        Set up the system of ODEs to be used for computing the
        deterministic trajectory of all the species in the given processes.
        The equations consist of sympy objects.

        Parameters
        ----------
        agent_based : bool, default: True
            If True, set up the agent-based (or microscopic) form of ODEs.
            For instance, for the process `2X -&gt; Y`, the ODE for species
            `X` would include an `X(X - 1)` term instead
            of `X^2` (the canonical form). If False, the canonical form
            of the ODEs is constructed.

        Notes
        -----
        The rate constant, `k`, for a given process is taken to be the mean
        of `k`, unless `k` was defined to be normally-distributed,
        in which case `k` is a 2-tuple and `k[0]` is the specified mean.

        Implementation note: Building up the ODE expressions by separately iterating
        over the processes for products and reactants. This is to properly
        handle 0th order processes for product species. For example, for the
        0th order process &#39; --&gt; X&#39; with rate constant k1, the ODE is dX/dt = k1.
        &#34;&#34;&#34;
        # Set up ODEs for product species
        for spec, procs in self._procs_by_product.items():
            terms = []
            for proc in procs:
                k_val = proc.k[0] if isinstance(proc.k, tuple) else mean(proc.k)

                if agent_based:
                    temp = [Mul(*[sympify(name, locals=_clash) - i for i in
                                  range(order)]) if name != &#39;&#39; else 1
                            for name, order in proc.reactants.items()]
                else:
                    temp = [Pow(sympify(name, locals=_clash), order) if name != &#39;&#39; else 1
                            for name, order in proc.reactants.items()]

                new_term = Mul(proc.products[spec], k_val, *temp)
                terms.append(new_term * self.get_term_multiplier(proc))

            if spec in self.odes:
                self.odes[spec] += Add(*terms)
            else:
                self.odes[spec] = Add(*terms)

        # Set up ODEs for reactant species
        for spec, procs in self._procs_by_reactant.items():
            terms = []
            for proc in procs:
                k_val = proc.k[0] if isinstance(proc.k, tuple) else mean(proc.k)

                if agent_based:
                    temp = [Mul(*[sympify(name, locals=_clash) - i for i in range(order)]) for
                            name, order in proc.reactants.items()]
                else:
                    temp = [Pow(sympify(name, locals=_clash), order) for name, order in
                            proc.reactants.items()]

                new_term = Mul(proc.reactants[spec], -1 * k_val, *temp)
                terms.append(new_term * self.get_term_multiplier(proc))

            if spec in self.odes:
                self.odes[spec] += Add(*terms)
            else:
                self.odes[spec] = Add(*terms)

        self.species_with_ode = [sp for sp in self.odes.keys()]

        # Handle species whose population remains constant (e.g., a catalyst)
        if len(self._all_species) != len(self.species_with_ode):
            missing_species = self._all_species - set(self.species_with_ode)
            for m in missing_species:
                self.odes[m] = sympify(0)  # dm/dt = 0
                self.species_with_ode.append(m)

    @staticmethod
    def get_term_multiplier(proc):
        &#34;&#34;&#34;
        Generate the multiplicative term (or terms) needed for generating the
        correct algebraic expressions for specialized processes
        (such as Michaelis-Menten and regulated processes).
        &#34;&#34;&#34;
        if isinstance(proc, MichaelisMentenProcess):
            Km_val = proc.Km[0] if isinstance(proc.Km, tuple) else mean(proc.Km)
            c = symbols(proc.catalyst)
            return c / (Km_val + sympify(proc.reacts_[0], locals=_clash))
        elif issubclass(type(proc), RegulatedProcess):
            if isinstance(proc.regulating_species, list):
                term = 1
                for sp, a, Kval, hc in zip(proc.regulating_species, proc.alpha, proc.K50, proc.nH):
                    K50_val = Kval[0] if isinstance(Kval, tuple) else mean(Kval)
                    ratio = (symbols(sp) / K50_val) ** hc
                    term *= (1 + a * ratio) / (1 + ratio)
            else:
                K50_val = proc.K50[0] if isinstance(proc.K50, tuple) else mean(proc.K50)
                ratio = (symbols(proc.regulating_species) / K50_val) ** proc.nH
                term = (1 + proc.alpha * ratio) / (1 + ratio)

            if isinstance(proc, RegulatedMichaelisMentenProcess):
                Km_val = proc.Km[0] if isinstance(proc.Km, tuple) else mean(proc.Km)
                c = symbols(proc.catalyst)
                term *= c / (Km_val + sympify(proc.reacts_[0], locals=_clash))

            return term
        else:
            return 1

    def solve_ODEs(self):
        &#34;&#34;&#34;
        Solve system of ordinary differential equations (ODEs).

        Notes
        -----
        Using the solver `scipy.integrate.solve_ivp`,
        whose method can be one of the following:

        - RK45 : Explicit Runge-Kutta method of order 5(4).
        - RK23 : Explicit Runge-Kutta method of order 3(2).
        - DOP853 : Explicit Runge-Kutta method of order 8.
        - Radau : Implicit Runge-Kutta method of the Radau IIA family of order 5
        - BDF : Implicit multistep variable-order (1 to 5) method based on a
                 backward differentiation formula for the derivative approximation.
        - LSODA : Adams/BDF method with automatic stiffness detection and switching.

        Documentation
        -------------
        https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.solve_ivp.html
        &#34;&#34;&#34;
        # Converting ODE expressions: sympy -&gt; scipy/numpy
        _odes_lambdified = lambdify([sympify(sp, locals=_clash) for sp in self.odes.keys()],
                                    list(self.odes.values()))

        # Converting initial population values to a list to ensure that the order of
        # species-specific ODEs and initial values are correctly ordered.
        p0_list = [self.p0[sp] for sp in self.odes.keys()]
        self.odes_sol = solve_ivp(lambda t, S: _odes_lambdified(*S),
                                  t_span=[self.t_min, self.t_max],
                                  y0=p0_list,
                                  method=self.ode_method,
                                  t_eval=None,  # Specify points where the solution is desired
                                  dense_output=True)  # Compute a continuous solution

    def get_fixed_pts(self):
        &#34;&#34;&#34;
        Not currently implemented.
        &#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="abstochkin.de_calcs.DEcalcs"><code class="flex name class">
<span>class <span class="ident">DEcalcs</span></span>
<span>(</span><span>p0:Â dict, t_min:Â floatÂ |Â int, t_max:Â floatÂ |Â int, processes:Â list, ode_method:Â str, time_unit:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>Perform deterministic calculations given the processes specified
in an AbStochKin simulation object.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>p0</code></strong> :&ensp;<code>dict[str: int]</code></dt>
<dd>Dictionary specifying the initial population sizes of all
species in the given processes.</dd>
<dt><strong><code>t_min</code></strong> :&ensp;<code>float</code> or <code>int</code></dt>
<dd>Numerical value of the start of simulated time in the units
specified in the class attribute <code>time_unit</code>.</dd>
<dt><strong><code>t_max</code></strong> :&ensp;<code>float</code> or <code>int</code></dt>
<dd>Numerical value of the end of simulated time in the units
specified in the class attribute <code>time_unit</code>.</dd>
<dt><strong><code>processes</code></strong> :&ensp;<code>list</code> of <code>Process objects</code></dt>
<dd>A list of all the processes that define the system of ODEs.
Each process is a <code>Process</code> object.</dd>
<dt><strong><code>ode_method</code></strong> :&ensp;<code>str</code></dt>
<dd>Method for the ODE solver to use.</dd>
<dt><strong><code>time_unit</code></strong> :&ensp;<code>str</code></dt>
<dd>A string of the time unit to be used for describing the
kinetics of the given processes.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DEcalcs:
    &#34;&#34;&#34;
    Perform deterministic calculations given the processes specified
    in an AbStochKin simulation object.

    Attributes
    ----------
    p0 : dict[str: int]
        Dictionary specifying the initial population sizes of all
        species in the given processes.
    t_min : float or int
        Numerical value of the start of simulated time in the units
        specified in the class attribute `time_unit`.
    t_max : float or int
        Numerical value of the end of simulated time in the units
        specified in the class attribute `time_unit`.
    processes : list of Process objects
        A list of all the processes that define the system of ODEs.
        Each process is a `Process` object.
    ode_method: str
        Method for the ODE solver to use.
    time_unit: str
        A string of the time unit to be used for describing the
        kinetics of the given processes.
    &#34;&#34;&#34;

    def __init__(self,
                 p0: dict,
                 t_min: int | float,
                 t_max: int | float,
                 processes: list,
                 ode_method: str,
                 time_unit: str):
        self.p0 = p0
        self.t_min = t_min
        self.t_max = t_max
        self.processes = processes
        self.ode_method = ode_method
        self.time_unit = time_unit

        # *** For computing and storing the solution to the system of ODEs. ***
        self._all_species, self._procs_by_reactant, self._procs_by_product = update_all_species(
            tuple(self.processes))
        self.odes = dict()  # store species-specific ODEs
        self.odes_sol = None  # numerical solution of species trajectories

        self.species_with_ode = list()
        self.jac = None  # Jacobian matrix
        self.fixed_pts = dict()  # dictionary of fixed points

        self.setup_ODEs()
        self.get_fixed_pts()

    def setup_ODEs(self, agent_based=True):
        &#34;&#34;&#34;
        Set up the system of ODEs to be used for computing the
        deterministic trajectory of all the species in the given processes.
        The equations consist of sympy objects.

        Parameters
        ----------
        agent_based : bool, default: True
            If True, set up the agent-based (or microscopic) form of ODEs.
            For instance, for the process `2X -&gt; Y`, the ODE for species
            `X` would include an `X(X - 1)` term instead
            of `X^2` (the canonical form). If False, the canonical form
            of the ODEs is constructed.

        Notes
        -----
        The rate constant, `k`, for a given process is taken to be the mean
        of `k`, unless `k` was defined to be normally-distributed,
        in which case `k` is a 2-tuple and `k[0]` is the specified mean.

        Implementation note: Building up the ODE expressions by separately iterating
        over the processes for products and reactants. This is to properly
        handle 0th order processes for product species. For example, for the
        0th order process &#39; --&gt; X&#39; with rate constant k1, the ODE is dX/dt = k1.
        &#34;&#34;&#34;
        # Set up ODEs for product species
        for spec, procs in self._procs_by_product.items():
            terms = []
            for proc in procs:
                k_val = proc.k[0] if isinstance(proc.k, tuple) else mean(proc.k)

                if agent_based:
                    temp = [Mul(*[sympify(name, locals=_clash) - i for i in
                                  range(order)]) if name != &#39;&#39; else 1
                            for name, order in proc.reactants.items()]
                else:
                    temp = [Pow(sympify(name, locals=_clash), order) if name != &#39;&#39; else 1
                            for name, order in proc.reactants.items()]

                new_term = Mul(proc.products[spec], k_val, *temp)
                terms.append(new_term * self.get_term_multiplier(proc))

            if spec in self.odes:
                self.odes[spec] += Add(*terms)
            else:
                self.odes[spec] = Add(*terms)

        # Set up ODEs for reactant species
        for spec, procs in self._procs_by_reactant.items():
            terms = []
            for proc in procs:
                k_val = proc.k[0] if isinstance(proc.k, tuple) else mean(proc.k)

                if agent_based:
                    temp = [Mul(*[sympify(name, locals=_clash) - i for i in range(order)]) for
                            name, order in proc.reactants.items()]
                else:
                    temp = [Pow(sympify(name, locals=_clash), order) for name, order in
                            proc.reactants.items()]

                new_term = Mul(proc.reactants[spec], -1 * k_val, *temp)
                terms.append(new_term * self.get_term_multiplier(proc))

            if spec in self.odes:
                self.odes[spec] += Add(*terms)
            else:
                self.odes[spec] = Add(*terms)

        self.species_with_ode = [sp for sp in self.odes.keys()]

        # Handle species whose population remains constant (e.g., a catalyst)
        if len(self._all_species) != len(self.species_with_ode):
            missing_species = self._all_species - set(self.species_with_ode)
            for m in missing_species:
                self.odes[m] = sympify(0)  # dm/dt = 0
                self.species_with_ode.append(m)

    @staticmethod
    def get_term_multiplier(proc):
        &#34;&#34;&#34;
        Generate the multiplicative term (or terms) needed for generating the
        correct algebraic expressions for specialized processes
        (such as Michaelis-Menten and regulated processes).
        &#34;&#34;&#34;
        if isinstance(proc, MichaelisMentenProcess):
            Km_val = proc.Km[0] if isinstance(proc.Km, tuple) else mean(proc.Km)
            c = symbols(proc.catalyst)
            return c / (Km_val + sympify(proc.reacts_[0], locals=_clash))
        elif issubclass(type(proc), RegulatedProcess):
            if isinstance(proc.regulating_species, list):
                term = 1
                for sp, a, Kval, hc in zip(proc.regulating_species, proc.alpha, proc.K50, proc.nH):
                    K50_val = Kval[0] if isinstance(Kval, tuple) else mean(Kval)
                    ratio = (symbols(sp) / K50_val) ** hc
                    term *= (1 + a * ratio) / (1 + ratio)
            else:
                K50_val = proc.K50[0] if isinstance(proc.K50, tuple) else mean(proc.K50)
                ratio = (symbols(proc.regulating_species) / K50_val) ** proc.nH
                term = (1 + proc.alpha * ratio) / (1 + ratio)

            if isinstance(proc, RegulatedMichaelisMentenProcess):
                Km_val = proc.Km[0] if isinstance(proc.Km, tuple) else mean(proc.Km)
                c = symbols(proc.catalyst)
                term *= c / (Km_val + sympify(proc.reacts_[0], locals=_clash))

            return term
        else:
            return 1

    def solve_ODEs(self):
        &#34;&#34;&#34;
        Solve system of ordinary differential equations (ODEs).

        Notes
        -----
        Using the solver `scipy.integrate.solve_ivp`,
        whose method can be one of the following:

        - RK45 : Explicit Runge-Kutta method of order 5(4).
        - RK23 : Explicit Runge-Kutta method of order 3(2).
        - DOP853 : Explicit Runge-Kutta method of order 8.
        - Radau : Implicit Runge-Kutta method of the Radau IIA family of order 5
        - BDF : Implicit multistep variable-order (1 to 5) method based on a
                 backward differentiation formula for the derivative approximation.
        - LSODA : Adams/BDF method with automatic stiffness detection and switching.

        Documentation
        -------------
        https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.solve_ivp.html
        &#34;&#34;&#34;
        # Converting ODE expressions: sympy -&gt; scipy/numpy
        _odes_lambdified = lambdify([sympify(sp, locals=_clash) for sp in self.odes.keys()],
                                    list(self.odes.values()))

        # Converting initial population values to a list to ensure that the order of
        # species-specific ODEs and initial values are correctly ordered.
        p0_list = [self.p0[sp] for sp in self.odes.keys()]
        self.odes_sol = solve_ivp(lambda t, S: _odes_lambdified(*S),
                                  t_span=[self.t_min, self.t_max],
                                  y0=p0_list,
                                  method=self.ode_method,
                                  t_eval=None,  # Specify points where the solution is desired
                                  dense_output=True)  # Compute a continuous solution

    def get_fixed_pts(self):
        &#34;&#34;&#34;
        Not currently implemented.
        &#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="abstochkin.de_calcs.DEcalcs.get_term_multiplier"><code class="name flex">
<span>def <span class="ident">get_term_multiplier</span></span>(<span>proc)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate the multiplicative term (or terms) needed for generating the
correct algebraic expressions for specialized processes
(such as Michaelis-Menten and regulated processes).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_term_multiplier(proc):
    &#34;&#34;&#34;
    Generate the multiplicative term (or terms) needed for generating the
    correct algebraic expressions for specialized processes
    (such as Michaelis-Menten and regulated processes).
    &#34;&#34;&#34;
    if isinstance(proc, MichaelisMentenProcess):
        Km_val = proc.Km[0] if isinstance(proc.Km, tuple) else mean(proc.Km)
        c = symbols(proc.catalyst)
        return c / (Km_val + sympify(proc.reacts_[0], locals=_clash))
    elif issubclass(type(proc), RegulatedProcess):
        if isinstance(proc.regulating_species, list):
            term = 1
            for sp, a, Kval, hc in zip(proc.regulating_species, proc.alpha, proc.K50, proc.nH):
                K50_val = Kval[0] if isinstance(Kval, tuple) else mean(Kval)
                ratio = (symbols(sp) / K50_val) ** hc
                term *= (1 + a * ratio) / (1 + ratio)
        else:
            K50_val = proc.K50[0] if isinstance(proc.K50, tuple) else mean(proc.K50)
            ratio = (symbols(proc.regulating_species) / K50_val) ** proc.nH
            term = (1 + proc.alpha * ratio) / (1 + ratio)

        if isinstance(proc, RegulatedMichaelisMentenProcess):
            Km_val = proc.Km[0] if isinstance(proc.Km, tuple) else mean(proc.Km)
            c = symbols(proc.catalyst)
            term *= c / (Km_val + sympify(proc.reacts_[0], locals=_clash))

        return term
    else:
        return 1</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="abstochkin.de_calcs.DEcalcs.get_fixed_pts"><code class="name flex">
<span>def <span class="ident">get_fixed_pts</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Not currently implemented.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_fixed_pts(self):
    &#34;&#34;&#34;
    Not currently implemented.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="abstochkin.de_calcs.DEcalcs.setup_ODEs"><code class="name flex">
<span>def <span class="ident">setup_ODEs</span></span>(<span>self, agent_based=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Set up the system of ODEs to be used for computing the
deterministic trajectory of all the species in the given processes.
The equations consist of sympy objects.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>agent_based</code></strong> :&ensp;<code>bool</code>, default<code>: True</code></dt>
<dd>If True, set up the agent-based (or microscopic) form of ODEs.
For instance, for the process <code>2X -&gt; Y</code>, the ODE for species
<code>X</code> would include an <code>X(X - 1)</code> term instead
of <code>X^2</code> (the canonical form). If False, the canonical form
of the ODEs is constructed.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The rate constant, <code>k</code>, for a given process is taken to be the mean
of <code>k</code>, unless <code>k</code> was defined to be normally-distributed,
in which case <code>k</code> is a 2-tuple and <code>k[0]</code> is the specified mean.</p>
<p>Implementation note: Building up the ODE expressions by separately iterating
over the processes for products and reactants. This is to properly
handle 0th order processes for product species. For example, for the
0th order process ' &ndash;&gt; X' with rate constant k1, the ODE is dX/dt = k1.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_ODEs(self, agent_based=True):
    &#34;&#34;&#34;
    Set up the system of ODEs to be used for computing the
    deterministic trajectory of all the species in the given processes.
    The equations consist of sympy objects.

    Parameters
    ----------
    agent_based : bool, default: True
        If True, set up the agent-based (or microscopic) form of ODEs.
        For instance, for the process `2X -&gt; Y`, the ODE for species
        `X` would include an `X(X - 1)` term instead
        of `X^2` (the canonical form). If False, the canonical form
        of the ODEs is constructed.

    Notes
    -----
    The rate constant, `k`, for a given process is taken to be the mean
    of `k`, unless `k` was defined to be normally-distributed,
    in which case `k` is a 2-tuple and `k[0]` is the specified mean.

    Implementation note: Building up the ODE expressions by separately iterating
    over the processes for products and reactants. This is to properly
    handle 0th order processes for product species. For example, for the
    0th order process &#39; --&gt; X&#39; with rate constant k1, the ODE is dX/dt = k1.
    &#34;&#34;&#34;
    # Set up ODEs for product species
    for spec, procs in self._procs_by_product.items():
        terms = []
        for proc in procs:
            k_val = proc.k[0] if isinstance(proc.k, tuple) else mean(proc.k)

            if agent_based:
                temp = [Mul(*[sympify(name, locals=_clash) - i for i in
                              range(order)]) if name != &#39;&#39; else 1
                        for name, order in proc.reactants.items()]
            else:
                temp = [Pow(sympify(name, locals=_clash), order) if name != &#39;&#39; else 1
                        for name, order in proc.reactants.items()]

            new_term = Mul(proc.products[spec], k_val, *temp)
            terms.append(new_term * self.get_term_multiplier(proc))

        if spec in self.odes:
            self.odes[spec] += Add(*terms)
        else:
            self.odes[spec] = Add(*terms)

    # Set up ODEs for reactant species
    for spec, procs in self._procs_by_reactant.items():
        terms = []
        for proc in procs:
            k_val = proc.k[0] if isinstance(proc.k, tuple) else mean(proc.k)

            if agent_based:
                temp = [Mul(*[sympify(name, locals=_clash) - i for i in range(order)]) for
                        name, order in proc.reactants.items()]
            else:
                temp = [Pow(sympify(name, locals=_clash), order) for name, order in
                        proc.reactants.items()]

            new_term = Mul(proc.reactants[spec], -1 * k_val, *temp)
            terms.append(new_term * self.get_term_multiplier(proc))

        if spec in self.odes:
            self.odes[spec] += Add(*terms)
        else:
            self.odes[spec] = Add(*terms)

    self.species_with_ode = [sp for sp in self.odes.keys()]

    # Handle species whose population remains constant (e.g., a catalyst)
    if len(self._all_species) != len(self.species_with_ode):
        missing_species = self._all_species - set(self.species_with_ode)
        for m in missing_species:
            self.odes[m] = sympify(0)  # dm/dt = 0
            self.species_with_ode.append(m)</code></pre>
</details>
</dd>
<dt id="abstochkin.de_calcs.DEcalcs.solve_ODEs"><code class="name flex">
<span>def <span class="ident">solve_ODEs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Solve system of ordinary differential equations (ODEs).</p>
<h2 id="notes">Notes</h2>
<p>Using the solver <code>scipy.integrate.solve_ivp</code>,
whose method can be one of the following:</p>
<ul>
<li>RK45 : Explicit Runge-Kutta method of order 5(4).</li>
<li>RK23 : Explicit Runge-Kutta method of order 3(2).</li>
<li>DOP853 : Explicit Runge-Kutta method of order 8.</li>
<li>Radau : Implicit Runge-Kutta method of the Radau IIA family of order 5</li>
<li>BDF : Implicit multistep variable-order (1 to 5) method based on a
backward differentiation formula for the derivative approximation.</li>
<li>LSODA : Adams/BDF method with automatic stiffness detection and switching.</li>
</ul>
<h2 id="documentation">Documentation</h2>
<p><a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.solve_ivp.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.solve_ivp.html</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def solve_ODEs(self):
    &#34;&#34;&#34;
    Solve system of ordinary differential equations (ODEs).

    Notes
    -----
    Using the solver `scipy.integrate.solve_ivp`,
    whose method can be one of the following:

    - RK45 : Explicit Runge-Kutta method of order 5(4).
    - RK23 : Explicit Runge-Kutta method of order 3(2).
    - DOP853 : Explicit Runge-Kutta method of order 8.
    - Radau : Implicit Runge-Kutta method of the Radau IIA family of order 5
    - BDF : Implicit multistep variable-order (1 to 5) method based on a
             backward differentiation formula for the derivative approximation.
    - LSODA : Adams/BDF method with automatic stiffness detection and switching.

    Documentation
    -------------
    https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.solve_ivp.html
    &#34;&#34;&#34;
    # Converting ODE expressions: sympy -&gt; scipy/numpy
    _odes_lambdified = lambdify([sympify(sp, locals=_clash) for sp in self.odes.keys()],
                                list(self.odes.values()))

    # Converting initial population values to a list to ensure that the order of
    # species-specific ODEs and initial values are correctly ordered.
    p0_list = [self.p0[sp] for sp in self.odes.keys()]
    self.odes_sol = solve_ivp(lambda t, S: _odes_lambdified(*S),
                              t_span=[self.t_min, self.t_max],
                              y0=p0_list,
                              method=self.ode_method,
                              t_eval=None,  # Specify points where the solution is desired
                              dense_output=True)  # Compute a continuous solution</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="abstochkin" href="index.html">abstochkin</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="abstochkin.de_calcs.DEcalcs" href="#abstochkin.de_calcs.DEcalcs">DEcalcs</a></code></h4>
<ul class="">
<li><code><a title="abstochkin.de_calcs.DEcalcs.get_fixed_pts" href="#abstochkin.de_calcs.DEcalcs.get_fixed_pts">get_fixed_pts</a></code></li>
<li><code><a title="abstochkin.de_calcs.DEcalcs.get_term_multiplier" href="#abstochkin.de_calcs.DEcalcs.get_term_multiplier">get_term_multiplier</a></code></li>
<li><code><a title="abstochkin.de_calcs.DEcalcs.setup_ODEs" href="#abstochkin.de_calcs.DEcalcs.setup_ODEs">setup_ODEs</a></code></li>
<li><code><a title="abstochkin.de_calcs.DEcalcs.solve_ODEs" href="#abstochkin.de_calcs.DEcalcs.solve_ODEs">solve_ODEs</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
Â© Copyright 2024, Alex Plakantonakis.
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>