# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

import httpx

from .core.api_error import ApiError
from .core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from .core.jsonable_encoder import jsonable_encoder
from .core.remove_none_from_dict import remove_none_from_dict
from .environment import ScorecardEnvironment
from .errors.unprocessable_entity_error import UnprocessableEntityError
from .resources.run.client import AsyncRunClient, RunClient
from .resources.testcase.client import AsyncTestcaseClient, TestcaseClient
from .resources.testrecord.client import AsyncTestrecordClient, TestrecordClient
from .resources.testset.client import AsyncTestsetClient, TestsetClient
from .resources.v_1.client import AsyncV1Client, V1Client
from .types.http_validation_error import HttpValidationError

try:
    import pydantic.v1 as pydantic  # type: ignore
except ImportError:
    import pydantic  # type: ignore

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class Scorecard:
    def __init__(
        self,
        *,
        base_url: typing.Optional[str] = None,
        environment: ScorecardEnvironment = ScorecardEnvironment.DEFAULT,
        api_key: str,
        timeout: typing.Optional[float] = 60,
        httpx_client: typing.Optional[httpx.Client] = None,
    ):
        self._client_wrapper = SyncClientWrapper(
            base_url=_get_base_url(base_url=base_url, environment=environment),
            api_key=api_key,
            httpx_client=httpx.Client(timeout=timeout) if httpx_client is None else httpx_client,
        )
        self.v_1 = V1Client(client_wrapper=self._client_wrapper)
        self.testset = TestsetClient(client_wrapper=self._client_wrapper)
        self.testcase = TestcaseClient(client_wrapper=self._client_wrapper)
        self.testrecord = TestrecordClient(client_wrapper=self._client_wrapper)
        self.run = RunClient(client_wrapper=self._client_wrapper)

    def root_get(self) -> typing.Any:
        """
        Root endpoint that returns a welcome message.
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET", self._client_wrapper.get_base_url(), headers=self._client_wrapper.get_headers(), timeout=60
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_run_create_run_post(
        self,
        *,
        testset_id: int,
        scoring_config_id: int,
        status: typing.Optional[str] = OMIT,
        model_params: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
    ) -> typing.Any:
        """
        Create a new run.

        Parameters:
            - testset_id: int.

            - scoring_config_id: int.

            - status: typing.Optional[str].

            - model_params: typing.Optional[typing.Dict[str, typing.Any]].
        """
        _request: typing.Dict[str, typing.Any] = {"testset_id": testset_id, "scoring_config_id": scoring_config_id}
        if status is not OMIT:
            _request["status"] = status
        if model_params is not OMIT:
            _request["model_params"] = model_params
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "create-run"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_testset_testset_testset_id_get(self, testset_id: int) -> typing.Any:
        """
        Parameters:
            - testset_id: int.
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"testset/{testset_id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_testset_create_testset_post(
        self, *, name: str, description: typing.Optional[str] = OMIT, using_retrieval: bool
    ) -> typing.Any:
        """
        Create a new test set.

        Parameters:
            - name: str.

            - description: typing.Optional[str].

            - using_retrieval: bool.
        """
        _request: typing.Dict[str, typing.Any] = {"name": name, "using_retrieval": using_retrieval}
        if description is not OMIT:
            _request["description"] = description
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "create-testset"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def add_testcase_add_testcase_post(
        self,
        *,
        testset_id: int,
        user_query: str,
        context: typing.Optional[str] = OMIT,
        response: typing.Optional[str] = OMIT,
        ideal: typing.Optional[str] = OMIT,
    ) -> typing.Any:
        """
        Add a new test case to an existing test set.

        Parameters:
            - testset_id: int.

            - user_query: str.

            - context: typing.Optional[str].

            - response: typing.Optional[str].

            - ideal: typing.Optional[str].
        """
        _request: typing.Dict[str, typing.Any] = {"testset_id": testset_id, "user_query": user_query}
        if context is not OMIT:
            _request["context"] = context
        if response is not OMIT:
            _request["response"] = response
        if ideal is not OMIT:
            _request["ideal"] = ideal
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "add-testcase"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_testrecord_create_testrecord_post(
        self,
        *,
        auto_score: typing.Optional[bool] = None,
        run_id: int,
        testcase_id: int,
        model_response: str,
        user_query: typing.Optional[str] = OMIT,
        context: typing.Optional[str] = OMIT,
        prompt: typing.Optional[str] = OMIT,
        ideal: typing.Optional[str] = OMIT,
        debug_output: typing.Optional[str] = OMIT,
        model_params: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        testset_id: typing.Optional[int] = OMIT,
        status: typing.Optional[str] = OMIT,
    ) -> typing.Any:
        """
        Create a new test record.

        Parameters:
            - auto_score: typing.Optional[bool].

            - run_id: int.

            - testcase_id: int.

            - model_response: str.

            - user_query: typing.Optional[str].

            - context: typing.Optional[str].

            - prompt: typing.Optional[str].

            - ideal: typing.Optional[str].

            - debug_output: typing.Optional[str].

            - model_params: typing.Optional[typing.Dict[str, typing.Any]].

            - testset_id: typing.Optional[int].

            - status: typing.Optional[str].
        """
        _request: typing.Dict[str, typing.Any] = {
            "run_id": run_id,
            "testcase_id": testcase_id,
            "model_response": model_response,
        }
        if user_query is not OMIT:
            _request["user_query"] = user_query
        if context is not OMIT:
            _request["context"] = context
        if prompt is not OMIT:
            _request["prompt"] = prompt
        if ideal is not OMIT:
            _request["ideal"] = ideal
        if debug_output is not OMIT:
            _request["debug_output"] = debug_output
        if model_params is not OMIT:
            _request["model_params"] = model_params
        if testset_id is not OMIT:
            _request["testset_id"] = testset_id
        if status is not OMIT:
            _request["status"] = status
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "create-testrecord"),
            params=remove_none_from_dict({"auto_score": auto_score}),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_run_status_update_run_run_id_patch(self, run_id: int, *, status: str) -> typing.Any:
        """
        Update the status of a run.

        Parameters:
            - run_id: int.

            - status: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"update-run/{run_id}"),
            params=remove_none_from_dict({"status": status}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def github_status_github_status_testset_id_api_key_get(self, testset_id: int, api_key: str) -> typing.Any:
        """
        Get the status for Github.

        Parameters:
            - testset_id: int.

            - api_key: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"github-status/{testset_id}/{api_key}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncScorecard:
    def __init__(
        self,
        *,
        base_url: typing.Optional[str] = None,
        environment: ScorecardEnvironment = ScorecardEnvironment.DEFAULT,
        api_key: str,
        timeout: typing.Optional[float] = 60,
        httpx_client: typing.Optional[httpx.AsyncClient] = None,
    ):
        self._client_wrapper = AsyncClientWrapper(
            base_url=_get_base_url(base_url=base_url, environment=environment),
            api_key=api_key,
            httpx_client=httpx.AsyncClient(timeout=timeout) if httpx_client is None else httpx_client,
        )
        self.v_1 = AsyncV1Client(client_wrapper=self._client_wrapper)
        self.testset = AsyncTestsetClient(client_wrapper=self._client_wrapper)
        self.testcase = AsyncTestcaseClient(client_wrapper=self._client_wrapper)
        self.testrecord = AsyncTestrecordClient(client_wrapper=self._client_wrapper)
        self.run = AsyncRunClient(client_wrapper=self._client_wrapper)

    async def root_get(self) -> typing.Any:
        """
        Root endpoint that returns a welcome message.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET", self._client_wrapper.get_base_url(), headers=self._client_wrapper.get_headers(), timeout=60
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_run_create_run_post(
        self,
        *,
        testset_id: int,
        scoring_config_id: int,
        status: typing.Optional[str] = OMIT,
        model_params: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
    ) -> typing.Any:
        """
        Create a new run.

        Parameters:
            - testset_id: int.

            - scoring_config_id: int.

            - status: typing.Optional[str].

            - model_params: typing.Optional[typing.Dict[str, typing.Any]].
        """
        _request: typing.Dict[str, typing.Any] = {"testset_id": testset_id, "scoring_config_id": scoring_config_id}
        if status is not OMIT:
            _request["status"] = status
        if model_params is not OMIT:
            _request["model_params"] = model_params
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "create-run"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_testset_testset_testset_id_get(self, testset_id: int) -> typing.Any:
        """
        Parameters:
            - testset_id: int.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"testset/{testset_id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_testset_create_testset_post(
        self, *, name: str, description: typing.Optional[str] = OMIT, using_retrieval: bool
    ) -> typing.Any:
        """
        Create a new test set.

        Parameters:
            - name: str.

            - description: typing.Optional[str].

            - using_retrieval: bool.
        """
        _request: typing.Dict[str, typing.Any] = {"name": name, "using_retrieval": using_retrieval}
        if description is not OMIT:
            _request["description"] = description
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "create-testset"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def add_testcase_add_testcase_post(
        self,
        *,
        testset_id: int,
        user_query: str,
        context: typing.Optional[str] = OMIT,
        response: typing.Optional[str] = OMIT,
        ideal: typing.Optional[str] = OMIT,
    ) -> typing.Any:
        """
        Add a new test case to an existing test set.

        Parameters:
            - testset_id: int.

            - user_query: str.

            - context: typing.Optional[str].

            - response: typing.Optional[str].

            - ideal: typing.Optional[str].
        """
        _request: typing.Dict[str, typing.Any] = {"testset_id": testset_id, "user_query": user_query}
        if context is not OMIT:
            _request["context"] = context
        if response is not OMIT:
            _request["response"] = response
        if ideal is not OMIT:
            _request["ideal"] = ideal
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "add-testcase"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_testrecord_create_testrecord_post(
        self,
        *,
        auto_score: typing.Optional[bool] = None,
        run_id: int,
        testcase_id: int,
        model_response: str,
        user_query: typing.Optional[str] = OMIT,
        context: typing.Optional[str] = OMIT,
        prompt: typing.Optional[str] = OMIT,
        ideal: typing.Optional[str] = OMIT,
        debug_output: typing.Optional[str] = OMIT,
        model_params: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        testset_id: typing.Optional[int] = OMIT,
        status: typing.Optional[str] = OMIT,
    ) -> typing.Any:
        """
        Create a new test record.

        Parameters:
            - auto_score: typing.Optional[bool].

            - run_id: int.

            - testcase_id: int.

            - model_response: str.

            - user_query: typing.Optional[str].

            - context: typing.Optional[str].

            - prompt: typing.Optional[str].

            - ideal: typing.Optional[str].

            - debug_output: typing.Optional[str].

            - model_params: typing.Optional[typing.Dict[str, typing.Any]].

            - testset_id: typing.Optional[int].

            - status: typing.Optional[str].
        """
        _request: typing.Dict[str, typing.Any] = {
            "run_id": run_id,
            "testcase_id": testcase_id,
            "model_response": model_response,
        }
        if user_query is not OMIT:
            _request["user_query"] = user_query
        if context is not OMIT:
            _request["context"] = context
        if prompt is not OMIT:
            _request["prompt"] = prompt
        if ideal is not OMIT:
            _request["ideal"] = ideal
        if debug_output is not OMIT:
            _request["debug_output"] = debug_output
        if model_params is not OMIT:
            _request["model_params"] = model_params
        if testset_id is not OMIT:
            _request["testset_id"] = testset_id
        if status is not OMIT:
            _request["status"] = status
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "create-testrecord"),
            params=remove_none_from_dict({"auto_score": auto_score}),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_run_status_update_run_run_id_patch(self, run_id: int, *, status: str) -> typing.Any:
        """
        Update the status of a run.

        Parameters:
            - run_id: int.

            - status: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"update-run/{run_id}"),
            params=remove_none_from_dict({"status": status}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def github_status_github_status_testset_id_api_key_get(self, testset_id: int, api_key: str) -> typing.Any:
        """
        Get the status for Github.

        Parameters:
            - testset_id: int.

            - api_key: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"github-status/{testset_id}/{api_key}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


def _get_base_url(*, base_url: typing.Optional[str] = None, environment: ScorecardEnvironment) -> str:
    if base_url is not None:
        return base_url
    elif environment is not None:
        return environment.value
    else:
        raise Exception("Please pass in either base_url or environment to construct the client")
