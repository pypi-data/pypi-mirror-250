# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['T', 'O', 'GuardLike', 'qual', 'setname', 'insattr', 'attrmeta', 'attr']

# %% ../nbs/00_core.ipynb 6
from abc import abstractmethod
from functools import wraps

# %% ../nbs/00_core.ipynb 8
from typing import (Any, Self, Type, TypeVar, TypeAlias, TypeGuard, ClassVar, Callable, Optional,)

# %% ../nbs/00_core.ipynb 10
#| export


# %% ../nbs/00_core.ipynb 12
from nchr import DOT
from nlit import(
    GET, HAS, KEYS, #ATTR, DEFAULT,
    __DOC__, __NAME__, __MODULE__, __QUALNAME__, __ANNOTATIONS__,
)
from chck import iscall, isnone, notnone

# %% ../nbs/00_core.ipynb 14
#| export


# %% ../nbs/00_core.ipynb 16
T = TypeVar('T')
O = TypeVar('O')
GuardLike: TypeAlias = Callable[[O], TypeGuard[T]]
'''TypeAlias for a callable that takes an object of type O and returns a TypeGuard for type T.''';

# %% ../nbs/00_core.ipynb 18
def qual(attr: str, base: str = HAS, prefix: str = '', suffix: str = '') -> str:
    '''Produce a '__qualname__' for a function based on an attribute name.'''
    prefix, suffix = prefix or '', suffix or ''
    return f'{prefix}{base}{attr}{suffix}'
    
def setname(fn: Callable, attr: str, base: str = HAS, prefix: str = '', suffix: str = '') -> Callable:
    for a in (__NAME__, __QUALNAME__): setattr(fn, a, qual(attr, base, prefix, suffix))    
    return fn

# %% ../nbs/00_core.ipynb 20
def insattr(
    obj: object, 
    attr: str, 
    default = None,
    check: bool = True,
    guard: Optional[GuardLike] = notnone,
    checkobj: Optional[GuardLike] = None, 
    guardobj: Optional[GuardLike] = notnone, 
    rethas: bool = False,
    retself: bool = False,
    __value: Any = None,
):
    '''Get an attribute from an object and check its type.
    
    Parameters
    ----------
    obj : object
        The object to get the attribute from.
        
    attr : str
        The name of the attribute to get.
        
    default : Any, optional
        The default value to return if the attribute is not found, by default None.
        
    check : bool, default: True
        Whether to check the type of the attribute, by default True.
        
    guard : Optional[GuardLike], default: `notnone`
        The guard to check the type of the retrieved attribute, by default `notnone`.
        
    checkobj : Optional[GuardLike], default: None
        The guard to check the type of the object, by default None.
        
    guardobj : Optional[GuardLike], default: `notnone`
        The guard to check the type of the object, by default `notnone`.
        
    rethas : bool, default: False
        Whether to return the boolean result of the typeguard or the attribute, 
        by default False.
        
    retself : bool, default: False
        Whether to return the object if the attribute fails the guard, otherwise
        the default value is returned, by default False.
    '''
    # Step 1: Check if the object is of the correct type
    if (checkobj and iscall(guardobj)) and not guardobj(obj): 
        return default
    
    # Step 2: Try and get the attribute
    try: has = hasattr(obj, attr)
    except: has = False
    
    try: val = getattr(obj, attr, default)
    except: val = default
    if isnone(val): val = default
    if __value is not None: val = __value
        
    # Step 3: Check if the attribute is of the correct type
    passed = (has and check and iscall(guard)) and guard(val)
    if passed: return has if rethas else val
    
    # Step 4: value failed the guard, check if the boolean
    # i.e. typeguard result should be returned
    if rethas: return has
    
        
    # Step 5: value failed the guard, check if the object 
    # should be returned
    passed = (check and iscall(guard)) and guardobj(obj)
    if (retself and passed): return obj
    
    return default

# %% ../nbs/00_core.ipynb 22
class attrmeta(type):
    '''A metaclass for attributes to extend instance checks and equality.'''
    clsvars = ('attr', 'check', 'guard', 'checkobj', 'guardobj', 'retself', 'default')
    
    def __instancecheck__(cls: Type[Self], __instance: object) -> bool:
        return cls.__guard__(__instance)
    
    def __eq__(cls: Self, ins: object) -> bool:
        if isinstance(ins, cls): return True
        return super().__eq__(ins)
    
    def __hash__(cls: Self) -> int:
        return super().__hash__()
    
    @abstractmethod
    def __guard__(cls: Type[Self], ins: object) -> TypeGuard[Type[Self]]:
        '''Abstract method to be implemented by subclasses.'''
        
    def __init__(cls: Self, name: str, bases: tuple = tuple(), dct: dict = dict(), *args, **kwargs):
        super().__init__(name, bases, dct)
        for attr in cls.clsvars:
            setattr(cls, attr, kwargs.get(attr, getattr(cls, attr, None)))

    def __make_attr__(cls, attr: str, **kwargs):
        '''Make a new attribute class with the given attribute name.'''
        mdct = dict(__annotations__=cls.__annotations__, __module__=cls.__module__)
        cdct = {**mdct, **kwargs, **dict(attr=attr)}
        return cls.__class__(attr, (cls, ), cdct)
            
    def __make_many__(cls: Self, *attrs, **kwargs):
        if not all(isinstance(a, str) for a in attrs):
            raise TypeError('attribute names must be strings')
        return tuple(cls.__make_attr__(attr, **kwargs) for attr in attrs)
    
    def __many__(cls: Self, *args, **kwargs):
        if not all(isinstance(a, str) for a in args):
            if len(args): 
                return cls.__call__(cls, *args, **kwargs)
        return cls.__make_many__(*args, **kwargs)
    
    def __deco__(cls: Self, **kwargs) -> Self:
        def decorator(sub: type) -> Self:
            return cls.__make_attr__(sub.__name__, **kwargs)
        return decorator

# %% ../nbs/00_core.ipynb 24
class attr(metaclass=attrmeta):
    attr: ClassVar[str]
    check: ClassVar[bool] = True
    guard: ClassVar[Optional[GuardLike]] = notnone
    
    checkobj: ClassVar[Optional[bool]] = True
    guardobj: ClassVar[Optional[GuardLike]] = notnone
    
    retself: ClassVar[bool] = True
    default: ClassVar[Any] = None
    
    def __new__(cls, *attrs, **kwargs):
        if attrs: return cls.many(*attrs, **kwargs)
        if kwargs: return cls.deco(**kwargs)
        new = super().__new__(cls)
        return new

    @classmethod
    def make(cls: Self, *attrs, **kwargs) -> Self:
        return cls.__make_many__(*attrs, **kwargs)
    
    @classmethod
    def many(cls: Self, *attrs, **kwargs) -> Self:
        return cls.__many__(*attrs, **kwargs)
    
    @classmethod
    def deco(cls: Type[Self], **kwargs) -> Type[Self]:
        return cls.__deco__(**kwargs)
    
    @classmethod
    def new(cls: Self, attr: str, **kwargs) -> Self:
        return cls.__make_attr__(attr, **kwargs)
    
    def __init_subclass__(cls, *args, **kwargs) -> None:
        super().__init_subclass__()
        for attr in cls.clsvars:
            setattr(cls, attr, kwargs.get(attr, getattr(cls, attr, None)))
        if not cls.attr: cls.attr = cls.__name__.lower()
        return
    
    @classmethod
    def __guard__(cls: Type[Self], ins: object) -> TypeGuard[Type[Self]]:
        '''Abstract method to be implemented by subclasses.'''
        return cls.has(ins)
    
    @classmethod
    def kwds(cls) -> dict:
        return dict((a, getattr(cls, a)) for a in cls.clsvars)
    
    @classmethod
    def chain(cls, obj: object, *attrs: 'attr', **kwargs):
        kwds = cls.kwds()
        rethas = kwargs.get('rethas', False)
        for i, name in enumerate(attrs):
            if isinstance(name, str): 
                attr = cls.new(name, **kwds)
            
            if i == len(attr) - 1:
                return attr.has(obj) if rethas else attr.get(obj)
            
            kws = {**kwds, **dict(attr=attr, rethas=False)}
            obj = insattr(obj, **kws)
            
        return obj
    
    @classmethod
    def dot(cls, obj: object, **kwargs):
        names = cls.kwds().get('attr').split(DOT)
        return cls.chain(obj, *names, **kwargs)
    
    @classmethod
    @wraps(insattr)
    def get(cls, obj: object):
        if DOT in cls.attr: return cls.dot(obj, rethas=False)
        return insattr(obj, rethas=False, **cls.kwds())
    
    @classmethod
    @wraps(insattr)
    def has(cls, obj: object) -> TypeGuard[bool]:
        if DOT in cls.attr: return cls.dot(obj, rethas=True)
        return insattr(obj, rethas=True, **cls.kwds())
    
    def __call__(self, obj: object, *args, **kwargs) -> object:
        return self.get(obj) if kwargs.get('get', True) else self.has(obj)
